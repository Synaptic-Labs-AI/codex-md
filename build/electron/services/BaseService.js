"use strict";

/**
 * BaseService.js
 * Foundation class for all Electron main process services.
 * Provides common IPC handling setup and standardized error handling.
 */

const {
  ipcMain
} = require('electron');

// Global error handlers container to avoid duplicates
const errorHandlers = {
  uncaughtException: new Map(),
  unhandledRejection: new Map()
};

// Set higher max listeners to avoid warnings
process.setMaxListeners(20);
class BaseService {
  constructor() {
    this.serviceName = this.constructor.name;
    this.setupErrorHandling();

    // Maintain a list of registered handlers for this instance
    this._registeredHandlers = new Set();

    // We're removing the automatic setTimeout-based setupIpcHandlers call here
    // Instead, subclasses will explicitly call setupIpcHandlers when appropriate
    // This helps prevent duplicate handler registrations
  }

  /**
   * Sets up IPC handlers for the service.
   * Should be implemented by child classes to register specific handlers.
   */
  setupIpcHandlers() {
    // Override in subclasses
    console.log(`[${this.serviceName}] IPC handlers not implemented`);
  }

  /**
   * Sets up standardized error handling for the service.
   * Ensures errors are properly logged and propagated.
   */
  setupErrorHandling() {
    // Only register handlers once per service name to avoid duplicates
    if (!errorHandlers.uncaughtException.has(this.serviceName)) {
      const uncaughtHandler = error => {
        console.error(`[${this.serviceName}] Uncaught Exception:`, error);
      };
      errorHandlers.uncaughtException.set(this.serviceName, uncaughtHandler);
      process.on('uncaughtException', uncaughtHandler);
    }
    if (!errorHandlers.unhandledRejection.has(this.serviceName)) {
      const rejectionHandler = reason => {
        console.error(`[${this.serviceName}] Unhandled Rejection:`, reason);
      };
      errorHandlers.unhandledRejection.set(this.serviceName, rejectionHandler);
      process.on('unhandledRejection', rejectionHandler);
    }
  }

  /**
   * Helper method to register an IPC handler with error handling.
   * @param {string} channel - The IPC channel to listen on
   * @param {Function} handler - The handler function
   */
  registerHandler(channel, handler) {
    // Check if this channel already has a handler to prevent duplicate registration
    try {
      // We can't directly check for handler existence, so we'll use a workaround
      // by checking the registered channels on ipcMain (undocumented but works)
      const eventNames = ipcMain._eventsCount > 0 && ipcMain._events && Object.keys(ipcMain._events);
      const isHandlerRegistered = eventNames && eventNames.includes(`handle-${channel}`);
      if (isHandlerRegistered) {
        console.log(`[${this.serviceName}] Handler for ${channel} already registered, skipping`);
        return;
      }

      // Register the handler if it doesn't exist
      ipcMain.handle(channel, async (event, ...args) => {
        try {
          return await handler(event, ...args);
        } catch (error) {
          console.error(`[${this.serviceName}] Error in ${channel}:`, error);
          throw error; // Propagate to renderer
        }
      });
      console.log(`[${this.serviceName}] Registered handler for: ${channel}`);
    } catch (error) {
      console.error(`[${this.serviceName}] Error registering handler for ${channel}:`, error);
      // Attempt to register anyway, in case the error was in our check logic
      ipcMain.handle(channel, async (event, ...args) => {
        try {
          return await handler(event, ...args);
        } catch (error) {
          console.error(`[${this.serviceName}] Error in ${channel}:`, error);
          throw error; // Propagate to renderer
        }
      });
    }
  }

  /**
   * Helper method to unregister an IPC handler.
   * @param {string} channel - The IPC channel to unregister
   */
  unregisterHandler(channel) {
    ipcMain.removeHandler(channel);
    console.log(`[${this.serviceName}] Unregistered handler for: ${channel}`);
  }
}
module.exports = BaseService;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJpcGNNYWluIiwicmVxdWlyZSIsImVycm9ySGFuZGxlcnMiLCJ1bmNhdWdodEV4Y2VwdGlvbiIsIk1hcCIsInVuaGFuZGxlZFJlamVjdGlvbiIsInByb2Nlc3MiLCJzZXRNYXhMaXN0ZW5lcnMiLCJCYXNlU2VydmljZSIsImNvbnN0cnVjdG9yIiwic2VydmljZU5hbWUiLCJuYW1lIiwic2V0dXBFcnJvckhhbmRsaW5nIiwiX3JlZ2lzdGVyZWRIYW5kbGVycyIsIlNldCIsInNldHVwSXBjSGFuZGxlcnMiLCJjb25zb2xlIiwibG9nIiwiaGFzIiwidW5jYXVnaHRIYW5kbGVyIiwiZXJyb3IiLCJzZXQiLCJvbiIsInJlamVjdGlvbkhhbmRsZXIiLCJyZWFzb24iLCJyZWdpc3RlckhhbmRsZXIiLCJjaGFubmVsIiwiaGFuZGxlciIsImV2ZW50TmFtZXMiLCJfZXZlbnRzQ291bnQiLCJfZXZlbnRzIiwiT2JqZWN0Iiwia2V5cyIsImlzSGFuZGxlclJlZ2lzdGVyZWQiLCJpbmNsdWRlcyIsImhhbmRsZSIsImV2ZW50IiwiYXJncyIsInVucmVnaXN0ZXJIYW5kbGVyIiwicmVtb3ZlSGFuZGxlciIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvZWxlY3Ryb24vc2VydmljZXMvQmFzZVNlcnZpY2UuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIEJhc2VTZXJ2aWNlLmpzXHJcbiAqIEZvdW5kYXRpb24gY2xhc3MgZm9yIGFsbCBFbGVjdHJvbiBtYWluIHByb2Nlc3Mgc2VydmljZXMuXHJcbiAqIFByb3ZpZGVzIGNvbW1vbiBJUEMgaGFuZGxpbmcgc2V0dXAgYW5kIHN0YW5kYXJkaXplZCBlcnJvciBoYW5kbGluZy5cclxuICovXHJcblxyXG5jb25zdCB7IGlwY01haW4gfSA9IHJlcXVpcmUoJ2VsZWN0cm9uJyk7XHJcblxyXG4vLyBHbG9iYWwgZXJyb3IgaGFuZGxlcnMgY29udGFpbmVyIHRvIGF2b2lkIGR1cGxpY2F0ZXNcclxuY29uc3QgZXJyb3JIYW5kbGVycyA9IHtcclxuICAgIHVuY2F1Z2h0RXhjZXB0aW9uOiBuZXcgTWFwKCksXHJcbiAgICB1bmhhbmRsZWRSZWplY3Rpb246IG5ldyBNYXAoKVxyXG59O1xyXG5cclxuLy8gU2V0IGhpZ2hlciBtYXggbGlzdGVuZXJzIHRvIGF2b2lkIHdhcm5pbmdzXHJcbnByb2Nlc3Muc2V0TWF4TGlzdGVuZXJzKDIwKTtcclxuXHJcbmNsYXNzIEJhc2VTZXJ2aWNlIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMuc2VydmljZU5hbWUgPSB0aGlzLmNvbnN0cnVjdG9yLm5hbWU7XHJcbiAgICAgICAgdGhpcy5zZXR1cEVycm9ySGFuZGxpbmcoKTtcclxuXHJcbiAgICAgICAgLy8gTWFpbnRhaW4gYSBsaXN0IG9mIHJlZ2lzdGVyZWQgaGFuZGxlcnMgZm9yIHRoaXMgaW5zdGFuY2VcclxuICAgICAgICB0aGlzLl9yZWdpc3RlcmVkSGFuZGxlcnMgPSBuZXcgU2V0KCk7XHJcblxyXG4gICAgICAgIC8vIFdlJ3JlIHJlbW92aW5nIHRoZSBhdXRvbWF0aWMgc2V0VGltZW91dC1iYXNlZCBzZXR1cElwY0hhbmRsZXJzIGNhbGwgaGVyZVxyXG4gICAgICAgIC8vIEluc3RlYWQsIHN1YmNsYXNzZXMgd2lsbCBleHBsaWNpdGx5IGNhbGwgc2V0dXBJcGNIYW5kbGVycyB3aGVuIGFwcHJvcHJpYXRlXHJcbiAgICAgICAgLy8gVGhpcyBoZWxwcyBwcmV2ZW50IGR1cGxpY2F0ZSBoYW5kbGVyIHJlZ2lzdHJhdGlvbnNcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdXAgSVBDIGhhbmRsZXJzIGZvciB0aGUgc2VydmljZS5cclxuICAgICAqIFNob3VsZCBiZSBpbXBsZW1lbnRlZCBieSBjaGlsZCBjbGFzc2VzIHRvIHJlZ2lzdGVyIHNwZWNpZmljIGhhbmRsZXJzLlxyXG4gICAgICovXHJcbiAgICBzZXR1cElwY0hhbmRsZXJzKCkge1xyXG4gICAgICAgIC8vIE92ZXJyaWRlIGluIHN1YmNsYXNzZXNcclxuICAgICAgICBjb25zb2xlLmxvZyhgWyR7dGhpcy5zZXJ2aWNlTmFtZX1dIElQQyBoYW5kbGVycyBub3QgaW1wbGVtZW50ZWRgKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdXAgc3RhbmRhcmRpemVkIGVycm9yIGhhbmRsaW5nIGZvciB0aGUgc2VydmljZS5cclxuICAgICAqIEVuc3VyZXMgZXJyb3JzIGFyZSBwcm9wZXJseSBsb2dnZWQgYW5kIHByb3BhZ2F0ZWQuXHJcbiAgICAgKi9cclxuICAgIHNldHVwRXJyb3JIYW5kbGluZygpIHtcclxuICAgICAgICAvLyBPbmx5IHJlZ2lzdGVyIGhhbmRsZXJzIG9uY2UgcGVyIHNlcnZpY2UgbmFtZSB0byBhdm9pZCBkdXBsaWNhdGVzXHJcbiAgICAgICAgaWYgKCFlcnJvckhhbmRsZXJzLnVuY2F1Z2h0RXhjZXB0aW9uLmhhcyh0aGlzLnNlcnZpY2VOYW1lKSkge1xyXG4gICAgICAgICAgICBjb25zdCB1bmNhdWdodEhhbmRsZXIgPSAoZXJyb3IpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFske3RoaXMuc2VydmljZU5hbWV9XSBVbmNhdWdodCBFeGNlcHRpb246YCwgZXJyb3IpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBlcnJvckhhbmRsZXJzLnVuY2F1Z2h0RXhjZXB0aW9uLnNldCh0aGlzLnNlcnZpY2VOYW1lLCB1bmNhdWdodEhhbmRsZXIpO1xyXG4gICAgICAgICAgICBwcm9jZXNzLm9uKCd1bmNhdWdodEV4Y2VwdGlvbicsIHVuY2F1Z2h0SGFuZGxlcik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIWVycm9ySGFuZGxlcnMudW5oYW5kbGVkUmVqZWN0aW9uLmhhcyh0aGlzLnNlcnZpY2VOYW1lKSkge1xyXG4gICAgICAgICAgICBjb25zdCByZWplY3Rpb25IYW5kbGVyID0gKHJlYXNvbikgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgWyR7dGhpcy5zZXJ2aWNlTmFtZX1dIFVuaGFuZGxlZCBSZWplY3Rpb246YCwgcmVhc29uKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgZXJyb3JIYW5kbGVycy51bmhhbmRsZWRSZWplY3Rpb24uc2V0KHRoaXMuc2VydmljZU5hbWUsIHJlamVjdGlvbkhhbmRsZXIpO1xyXG4gICAgICAgICAgICBwcm9jZXNzLm9uKCd1bmhhbmRsZWRSZWplY3Rpb24nLCByZWplY3Rpb25IYW5kbGVyKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBIZWxwZXIgbWV0aG9kIHRvIHJlZ2lzdGVyIGFuIElQQyBoYW5kbGVyIHdpdGggZXJyb3IgaGFuZGxpbmcuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhbm5lbCAtIFRoZSBJUEMgY2hhbm5lbCB0byBsaXN0ZW4gb25cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIgLSBUaGUgaGFuZGxlciBmdW5jdGlvblxyXG4gICAgICovXHJcbiAgICByZWdpc3RlckhhbmRsZXIoY2hhbm5lbCwgaGFuZGxlcikge1xyXG4gICAgICAgIC8vIENoZWNrIGlmIHRoaXMgY2hhbm5lbCBhbHJlYWR5IGhhcyBhIGhhbmRsZXIgdG8gcHJldmVudCBkdXBsaWNhdGUgcmVnaXN0cmF0aW9uXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgLy8gV2UgY2FuJ3QgZGlyZWN0bHkgY2hlY2sgZm9yIGhhbmRsZXIgZXhpc3RlbmNlLCBzbyB3ZSdsbCB1c2UgYSB3b3JrYXJvdW5kXHJcbiAgICAgICAgICAgIC8vIGJ5IGNoZWNraW5nIHRoZSByZWdpc3RlcmVkIGNoYW5uZWxzIG9uIGlwY01haW4gKHVuZG9jdW1lbnRlZCBidXQgd29ya3MpXHJcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50TmFtZXMgPSBpcGNNYWluLl9ldmVudHNDb3VudCA+IDAgJiYgaXBjTWFpbi5fZXZlbnRzICYmIE9iamVjdC5rZXlzKGlwY01haW4uX2V2ZW50cyk7XHJcbiAgICAgICAgICAgIGNvbnN0IGlzSGFuZGxlclJlZ2lzdGVyZWQgPSBldmVudE5hbWVzICYmIGV2ZW50TmFtZXMuaW5jbHVkZXMoYGhhbmRsZS0ke2NoYW5uZWx9YCk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBpZiAoaXNIYW5kbGVyUmVnaXN0ZXJlZCkge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYFske3RoaXMuc2VydmljZU5hbWV9XSBIYW5kbGVyIGZvciAke2NoYW5uZWx9IGFscmVhZHkgcmVnaXN0ZXJlZCwgc2tpcHBpbmdgKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy8gUmVnaXN0ZXIgdGhlIGhhbmRsZXIgaWYgaXQgZG9lc24ndCBleGlzdFxyXG4gICAgICAgICAgICBpcGNNYWluLmhhbmRsZShjaGFubmVsLCBhc3luYyAoZXZlbnQsIC4uLmFyZ3MpID0+IHtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IGhhbmRsZXIoZXZlbnQsIC4uLmFyZ3MpO1xyXG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBbJHt0aGlzLnNlcnZpY2VOYW1lfV0gRXJyb3IgaW4gJHtjaGFubmVsfTpgLCBlcnJvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7IC8vIFByb3BhZ2F0ZSB0byByZW5kZXJlclxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coYFske3RoaXMuc2VydmljZU5hbWV9XSBSZWdpc3RlcmVkIGhhbmRsZXIgZm9yOiAke2NoYW5uZWx9YCk7XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgWyR7dGhpcy5zZXJ2aWNlTmFtZX1dIEVycm9yIHJlZ2lzdGVyaW5nIGhhbmRsZXIgZm9yICR7Y2hhbm5lbH06YCwgZXJyb3IpO1xyXG4gICAgICAgICAgICAvLyBBdHRlbXB0IHRvIHJlZ2lzdGVyIGFueXdheSwgaW4gY2FzZSB0aGUgZXJyb3Igd2FzIGluIG91ciBjaGVjayBsb2dpY1xyXG4gICAgICAgICAgICBpcGNNYWluLmhhbmRsZShjaGFubmVsLCBhc3luYyAoZXZlbnQsIC4uLmFyZ3MpID0+IHtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IGhhbmRsZXIoZXZlbnQsIC4uLmFyZ3MpO1xyXG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBbJHt0aGlzLnNlcnZpY2VOYW1lfV0gRXJyb3IgaW4gJHtjaGFubmVsfTpgLCBlcnJvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7IC8vIFByb3BhZ2F0ZSB0byByZW5kZXJlclxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBIZWxwZXIgbWV0aG9kIHRvIHVucmVnaXN0ZXIgYW4gSVBDIGhhbmRsZXIuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhbm5lbCAtIFRoZSBJUEMgY2hhbm5lbCB0byB1bnJlZ2lzdGVyXHJcbiAgICAgKi9cclxuICAgIHVucmVnaXN0ZXJIYW5kbGVyKGNoYW5uZWwpIHtcclxuICAgICAgICBpcGNNYWluLnJlbW92ZUhhbmRsZXIoY2hhbm5lbCk7XHJcbiAgICAgICAgY29uc29sZS5sb2coYFske3RoaXMuc2VydmljZU5hbWV9XSBVbnJlZ2lzdGVyZWQgaGFuZGxlciBmb3I6ICR7Y2hhbm5lbH1gKTtcclxuICAgIH1cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBCYXNlU2VydmljZTtcclxuIl0sIm1hcHBpbmdzIjoiOztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsTUFBTTtFQUFFQTtBQUFRLENBQUMsR0FBR0MsT0FBTyxDQUFDLFVBQVUsQ0FBQzs7QUFFdkM7QUFDQSxNQUFNQyxhQUFhLEdBQUc7RUFDbEJDLGlCQUFpQixFQUFFLElBQUlDLEdBQUcsQ0FBQyxDQUFDO0VBQzVCQyxrQkFBa0IsRUFBRSxJQUFJRCxHQUFHLENBQUM7QUFDaEMsQ0FBQzs7QUFFRDtBQUNBRSxPQUFPLENBQUNDLGVBQWUsQ0FBQyxFQUFFLENBQUM7QUFFM0IsTUFBTUMsV0FBVyxDQUFDO0VBQ2RDLFdBQVdBLENBQUEsRUFBRztJQUNWLElBQUksQ0FBQ0MsV0FBVyxHQUFHLElBQUksQ0FBQ0QsV0FBVyxDQUFDRSxJQUFJO0lBQ3hDLElBQUksQ0FBQ0Msa0JBQWtCLENBQUMsQ0FBQzs7SUFFekI7SUFDQSxJQUFJLENBQUNDLG1CQUFtQixHQUFHLElBQUlDLEdBQUcsQ0FBQyxDQUFDOztJQUVwQztJQUNBO0lBQ0E7RUFDSjs7RUFFQTtBQUNKO0FBQ0E7QUFDQTtFQUNJQyxnQkFBZ0JBLENBQUEsRUFBRztJQUNmO0lBQ0FDLE9BQU8sQ0FBQ0MsR0FBRyxDQUFDLElBQUksSUFBSSxDQUFDUCxXQUFXLGdDQUFnQyxDQUFDO0VBQ3JFOztFQUVBO0FBQ0o7QUFDQTtBQUNBO0VBQ0lFLGtCQUFrQkEsQ0FBQSxFQUFHO0lBQ2pCO0lBQ0EsSUFBSSxDQUFDVixhQUFhLENBQUNDLGlCQUFpQixDQUFDZSxHQUFHLENBQUMsSUFBSSxDQUFDUixXQUFXLENBQUMsRUFBRTtNQUN4RCxNQUFNUyxlQUFlLEdBQUlDLEtBQUssSUFBSztRQUMvQkosT0FBTyxDQUFDSSxLQUFLLENBQUMsSUFBSSxJQUFJLENBQUNWLFdBQVcsdUJBQXVCLEVBQUVVLEtBQUss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