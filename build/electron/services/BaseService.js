"use strict";

/**
 * BaseService.js
 * Foundation class for all Electron main process services.
 * Provides common IPC handling setup and standardized error handling.
 */

const {
  ipcMain
} = require('electron');

// Global error handlers container to avoid duplicates
const errorHandlers = {
  uncaughtException: new Map(),
  unhandledRejection: new Map()
};

// Set higher max listeners to avoid warnings
process.setMaxListeners(20);
class BaseService {
  constructor() {
    this.serviceName = this.constructor.name;
    this.setupErrorHandling();

    // Delay IPC handler setup to allow subclasses to set skipHandlerSetup flag
    // We use setTimeout to ensure this runs after the constructor chain completes
    setTimeout(() => {
      if (this.skipHandlerSetup) {
        console.log(`[${this.serviceName}] Skipping IPC handler setup (skipHandlerSetup=true)`);
      } else {
        this.setupIpcHandlers();
      }
    }, 0);
  }

  /**
   * Sets up IPC handlers for the service.
   * Should be implemented by child classes to register specific handlers.
   */
  setupIpcHandlers() {
    // Override in subclasses
    console.log(`[${this.serviceName}] IPC handlers not implemented`);
  }

  /**
   * Sets up standardized error handling for the service.
   * Ensures errors are properly logged and propagated.
   */
  setupErrorHandling() {
    // Only register handlers once per service name to avoid duplicates
    if (!errorHandlers.uncaughtException.has(this.serviceName)) {
      const uncaughtHandler = error => {
        console.error(`[${this.serviceName}] Uncaught Exception:`, error);
      };
      errorHandlers.uncaughtException.set(this.serviceName, uncaughtHandler);
      process.on('uncaughtException', uncaughtHandler);
    }
    if (!errorHandlers.unhandledRejection.has(this.serviceName)) {
      const rejectionHandler = reason => {
        console.error(`[${this.serviceName}] Unhandled Rejection:`, reason);
      };
      errorHandlers.unhandledRejection.set(this.serviceName, rejectionHandler);
      process.on('unhandledRejection', rejectionHandler);
    }
  }

  /**
   * Helper method to register an IPC handler with error handling.
   * @param {string} channel - The IPC channel to listen on
   * @param {Function} handler - The handler function
   */
  registerHandler(channel, handler) {
    // Check if this channel already has a handler to prevent duplicate registration
    try {
      // We can't directly check for handler existence, so we'll use a workaround
      // by checking the registered channels on ipcMain (undocumented but works)
      const eventNames = ipcMain._eventsCount > 0 && ipcMain._events && Object.keys(ipcMain._events);
      const isHandlerRegistered = eventNames && eventNames.includes(`handle-${channel}`);
      if (isHandlerRegistered) {
        console.log(`[${this.serviceName}] Handler for ${channel} already registered, skipping`);
        return;
      }

      // Register the handler if it doesn't exist
      ipcMain.handle(channel, async (event, ...args) => {
        try {
          return await handler(event, ...args);
        } catch (error) {
          console.error(`[${this.serviceName}] Error in ${channel}:`, error);
          throw error; // Propagate to renderer
        }
      });
      console.log(`[${this.serviceName}] Registered handler for: ${channel}`);
    } catch (error) {
      console.error(`[${this.serviceName}] Error registering handler for ${channel}:`, error);
      // Attempt to register anyway, in case the error was in our check logic
      ipcMain.handle(channel, async (event, ...args) => {
        try {
          return await handler(event, ...args);
        } catch (error) {
          console.error(`[${this.serviceName}] Error in ${channel}:`, error);
          throw error; // Propagate to renderer
        }
      });
    }
  }

  /**
   * Helper method to unregister an IPC handler.
   * @param {string} channel - The IPC channel to unregister
   */
  unregisterHandler(channel) {
    ipcMain.removeHandler(channel);
    console.log(`[${this.serviceName}] Unregistered handler for: ${channel}`);
  }
}
module.exports = BaseService;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJpcGNNYWluIiwicmVxdWlyZSIsImVycm9ySGFuZGxlcnMiLCJ1bmNhdWdodEV4Y2VwdGlvbiIsIk1hcCIsInVuaGFuZGxlZFJlamVjdGlvbiIsInByb2Nlc3MiLCJzZXRNYXhMaXN0ZW5lcnMiLCJCYXNlU2VydmljZSIsImNvbnN0cnVjdG9yIiwic2VydmljZU5hbWUiLCJuYW1lIiwic2V0dXBFcnJvckhhbmRsaW5nIiwic2V0VGltZW91dCIsInNraXBIYW5kbGVyU2V0dXAiLCJjb25zb2xlIiwibG9nIiwic2V0dXBJcGNIYW5kbGVycyIsImhhcyIsInVuY2F1Z2h0SGFuZGxlciIsImVycm9yIiwic2V0Iiwib24iLCJyZWplY3Rpb25IYW5kbGVyIiwicmVhc29uIiwicmVnaXN0ZXJIYW5kbGVyIiwiY2hhbm5lbCIsImhhbmRsZXIiLCJldmVudE5hbWVzIiwiX2V2ZW50c0NvdW50IiwiX2V2ZW50cyIsIk9iamVjdCIsImtleXMiLCJpc0hhbmRsZXJSZWdpc3RlcmVkIiwiaW5jbHVkZXMiLCJoYW5kbGUiLCJldmVudCIsImFyZ3MiLCJ1bnJlZ2lzdGVySGFuZGxlciIsInJlbW92ZUhhbmRsZXIiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2VsZWN0cm9uL3NlcnZpY2VzL0Jhc2VTZXJ2aWNlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBCYXNlU2VydmljZS5qc1xyXG4gKiBGb3VuZGF0aW9uIGNsYXNzIGZvciBhbGwgRWxlY3Ryb24gbWFpbiBwcm9jZXNzIHNlcnZpY2VzLlxyXG4gKiBQcm92aWRlcyBjb21tb24gSVBDIGhhbmRsaW5nIHNldHVwIGFuZCBzdGFuZGFyZGl6ZWQgZXJyb3IgaGFuZGxpbmcuXHJcbiAqL1xyXG5cclxuY29uc3QgeyBpcGNNYWluIH0gPSByZXF1aXJlKCdlbGVjdHJvbicpO1xyXG5cclxuLy8gR2xvYmFsIGVycm9yIGhhbmRsZXJzIGNvbnRhaW5lciB0byBhdm9pZCBkdXBsaWNhdGVzXHJcbmNvbnN0IGVycm9ySGFuZGxlcnMgPSB7XHJcbiAgICB1bmNhdWdodEV4Y2VwdGlvbjogbmV3IE1hcCgpLFxyXG4gICAgdW5oYW5kbGVkUmVqZWN0aW9uOiBuZXcgTWFwKClcclxufTtcclxuXHJcbi8vIFNldCBoaWdoZXIgbWF4IGxpc3RlbmVycyB0byBhdm9pZCB3YXJuaW5nc1xyXG5wcm9jZXNzLnNldE1heExpc3RlbmVycygyMCk7XHJcblxyXG5jbGFzcyBCYXNlU2VydmljZSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLnNlcnZpY2VOYW1lID0gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lO1xyXG4gICAgICAgIHRoaXMuc2V0dXBFcnJvckhhbmRsaW5nKCk7XHJcblxyXG4gICAgICAgIC8vIERlbGF5IElQQyBoYW5kbGVyIHNldHVwIHRvIGFsbG93IHN1YmNsYXNzZXMgdG8gc2V0IHNraXBIYW5kbGVyU2V0dXAgZmxhZ1xyXG4gICAgICAgIC8vIFdlIHVzZSBzZXRUaW1lb3V0IHRvIGVuc3VyZSB0aGlzIHJ1bnMgYWZ0ZXIgdGhlIGNvbnN0cnVjdG9yIGNoYWluIGNvbXBsZXRlc1xyXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5za2lwSGFuZGxlclNldHVwKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgWyR7dGhpcy5zZXJ2aWNlTmFtZX1dIFNraXBwaW5nIElQQyBoYW5kbGVyIHNldHVwIChza2lwSGFuZGxlclNldHVwPXRydWUpYCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldHVwSXBjSGFuZGxlcnMoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sIDApO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB1cCBJUEMgaGFuZGxlcnMgZm9yIHRoZSBzZXJ2aWNlLlxyXG4gICAgICogU2hvdWxkIGJlIGltcGxlbWVudGVkIGJ5IGNoaWxkIGNsYXNzZXMgdG8gcmVnaXN0ZXIgc3BlY2lmaWMgaGFuZGxlcnMuXHJcbiAgICAgKi9cclxuICAgIHNldHVwSXBjSGFuZGxlcnMoKSB7XHJcbiAgICAgICAgLy8gT3ZlcnJpZGUgaW4gc3ViY2xhc3Nlc1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGBbJHt0aGlzLnNlcnZpY2VOYW1lfV0gSVBDIGhhbmRsZXJzIG5vdCBpbXBsZW1lbnRlZGApO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB1cCBzdGFuZGFyZGl6ZWQgZXJyb3IgaGFuZGxpbmcgZm9yIHRoZSBzZXJ2aWNlLlxyXG4gICAgICogRW5zdXJlcyBlcnJvcnMgYXJlIHByb3Blcmx5IGxvZ2dlZCBhbmQgcHJvcGFnYXRlZC5cclxuICAgICAqL1xyXG4gICAgc2V0dXBFcnJvckhhbmRsaW5nKCkge1xyXG4gICAgICAgIC8vIE9ubHkgcmVnaXN0ZXIgaGFuZGxlcnMgb25jZSBwZXIgc2VydmljZSBuYW1lIHRvIGF2b2lkIGR1cGxpY2F0ZXNcclxuICAgICAgICBpZiAoIWVycm9ySGFuZGxlcnMudW5jYXVnaHRFeGNlcHRpb24uaGFzKHRoaXMuc2VydmljZU5hbWUpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHVuY2F1Z2h0SGFuZGxlciA9IChlcnJvcikgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgWyR7dGhpcy5zZXJ2aWNlTmFtZX1dIFVuY2F1Z2h0IEV4Y2VwdGlvbjpgLCBlcnJvcik7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGVycm9ySGFuZGxlcnMudW5jYXVnaHRFeGNlcHRpb24uc2V0KHRoaXMuc2VydmljZU5hbWUsIHVuY2F1Z2h0SGFuZGxlcik7XHJcbiAgICAgICAgICAgIHByb2Nlc3Mub24oJ3VuY2F1Z2h0RXhjZXB0aW9uJywgdW5jYXVnaHRIYW5kbGVyKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghZXJyb3JIYW5kbGVycy51bmhhbmRsZWRSZWplY3Rpb24uaGFzKHRoaXMuc2VydmljZU5hbWUpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlamVjdGlvbkhhbmRsZXIgPSAocmVhc29uKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBbJHt0aGlzLnNlcnZpY2VOYW1lfV0gVW5oYW5kbGVkIFJlamVjdGlvbjpgLCByZWFzb24pO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBlcnJvckhhbmRsZXJzLnVuaGFuZGxlZFJlamVjdGlvbi5zZXQodGhpcy5zZXJ2aWNlTmFtZSwgcmVqZWN0aW9uSGFuZGxlcik7XHJcbiAgICAgICAgICAgIHByb2Nlc3Mub24oJ3VuaGFuZGxlZFJlamVjdGlvbicsIHJlamVjdGlvbkhhbmRsZXIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEhlbHBlciBtZXRob2QgdG8gcmVnaXN0ZXIgYW4gSVBDIGhhbmRsZXIgd2l0aCBlcnJvciBoYW5kbGluZy5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjaGFubmVsIC0gVGhlIElQQyBjaGFubmVsIHRvIGxpc3RlbiBvblxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciAtIFRoZSBoYW5kbGVyIGZ1bmN0aW9uXHJcbiAgICAgKi9cclxuICAgIHJlZ2lzdGVySGFuZGxlcihjaGFubmVsLCBoYW5kbGVyKSB7XHJcbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBjaGFubmVsIGFscmVhZHkgaGFzIGEgaGFuZGxlciB0byBwcmV2ZW50IGR1cGxpY2F0ZSByZWdpc3RyYXRpb25cclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAvLyBXZSBjYW4ndCBkaXJlY3RseSBjaGVjayBmb3IgaGFuZGxlciBleGlzdGVuY2UsIHNvIHdlJ2xsIHVzZSBhIHdvcmthcm91bmRcclxuICAgICAgICAgICAgLy8gYnkgY2hlY2tpbmcgdGhlIHJlZ2lzdGVyZWQgY2hhbm5lbHMgb24gaXBjTWFpbiAodW5kb2N1bWVudGVkIGJ1dCB3b3JrcylcclxuICAgICAgICAgICAgY29uc3QgZXZlbnROYW1lcyA9IGlwY01haW4uX2V2ZW50c0NvdW50ID4gMCAmJiBpcGNNYWluLl9ldmVudHMgJiYgT2JqZWN0LmtleXMoaXBjTWFpbi5fZXZlbnRzKTtcclxuICAgICAgICAgICAgY29uc3QgaXNIYW5kbGVyUmVnaXN0ZXJlZCA9IGV2ZW50TmFtZXMgJiYgZXZlbnROYW1lcy5pbmNsdWRlcyhgaGFuZGxlLSR7Y2hhbm5lbH1gKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGlmIChpc0hhbmRsZXJSZWdpc3RlcmVkKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgWyR7dGhpcy5zZXJ2aWNlTmFtZX1dIEhhbmRsZXIgZm9yICR7Y2hhbm5lbH0gYWxyZWFkeSByZWdpc3RlcmVkLCBza2lwcGluZ2ApO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvLyBSZWdpc3RlciB0aGUgaGFuZGxlciBpZiBpdCBkb2Vzbid0IGV4aXN0XHJcbiAgICAgICAgICAgIGlwY01haW4uaGFuZGxlKGNoYW5uZWwsIGFzeW5jIChldmVudCwgLi4uYXJncykgPT4ge1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgaGFuZGxlcihldmVudCwgLi4uYXJncyk7XHJcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFske3RoaXMuc2VydmljZU5hbWV9XSBFcnJvciBpbiAke2NoYW5uZWx9OmAsIGVycm9yKTtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjsgLy8gUHJvcGFnYXRlIHRvIHJlbmRlcmVyXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgWyR7dGhpcy5zZXJ2aWNlTmFtZX1dIFJlZ2lzdGVyZWQgaGFuZGxlciBmb3I6ICR7Y2hhbm5lbH1gKTtcclxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGBbJHt0aGlzLnNlcnZpY2VOYW1lfV0gRXJyb3IgcmVnaXN0ZXJpbmcgaGFuZGxlciBmb3IgJHtjaGFubmVsfTpgLCBlcnJvcik7XHJcbiAgICAgICAgICAgIC8vIEF0dGVtcHQgdG8gcmVnaXN0ZXIgYW55d2F5LCBpbiBjYXNlIHRoZSBlcnJvciB3YXMgaW4gb3VyIGNoZWNrIGxvZ2ljXHJcbiAgICAgICAgICAgIGlwY01haW4uaGFuZGxlKGNoYW5uZWwsIGFzeW5jIChldmVudCwgLi4uYXJncykgPT4ge1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgaGFuZGxlcihldmVudCwgLi4uYXJncyk7XHJcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFske3RoaXMuc2VydmljZU5hbWV9XSBFcnJvciBpbiAke2NoYW5uZWx9OmAsIGVycm9yKTtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjsgLy8gUHJvcGFnYXRlIHRvIHJlbmRlcmVyXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEhlbHBlciBtZXRob2QgdG8gdW5yZWdpc3RlciBhbiBJUEMgaGFuZGxlci5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjaGFubmVsIC0gVGhlIElQQyBjaGFubmVsIHRvIHVucmVnaXN0ZXJcclxuICAgICAqL1xyXG4gICAgdW5yZWdpc3RlckhhbmRsZXIoY2hhbm5lbCkge1xyXG4gICAgICAgIGlwY01haW4ucmVtb3ZlSGFuZGxlcihjaGFubmVsKTtcclxuICAgICAgICBjb25zb2xlLmxvZyhgWyR7dGhpcy5zZXJ2aWNlTmFtZX1dIFVucmVnaXN0ZXJlZCBoYW5kbGVyIGZvcjogJHtjaGFubmVsfWApO1xyXG4gICAgfVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEJhc2VTZXJ2aWNlO1xyXG4iXSwibWFwcGluZ3MiOiI7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxNQUFNO0VBQUVBO0FBQVEsQ0FBQyxHQUFHQyxPQUFPLENBQUMsVUFBVSxDQUFDOztBQUV2QztBQUNBLE1BQU1DLGFBQWEsR0FBRztFQUNsQkMsaUJBQWlCLEVBQUUsSUFBSUMsR0FBRyxDQUFDLENBQUM7RUFDNUJDLGtCQUFrQixFQUFFLElBQUlELEdBQUcsQ0FBQztBQUNoQyxDQUFDOztBQUVEO0FBQ0FFLE9BQU8sQ0FBQ0MsZUFBZSxDQUFDLEVBQUUsQ0FBQztBQUUzQixNQUFNQyxXQUFXLENBQUM7RUFDZEMsV0FBV0EsQ0FBQSxFQUFHO0lBQ1YsSUFBSSxDQUFDQyxXQUFXLEdBQUcsSUFBSSxDQUFDRCxXQUFXLENBQUNFLElBQUk7SUFDeEMsSUFBSSxDQUFDQyxrQkFBa0IsQ0FBQyxDQUFDOztJQUV6QjtJQUNBO0lBQ0FDLFVBQVUsQ0FBQyxNQUFNO01BQ2IsSUFBSSxJQUFJLENBQUNDLGdCQUFnQixFQUFFO1FBQ3ZCQyxPQUFPLENBQUNDLEdBQUcsQ0FBQyxJQUFJLElBQUksQ0FBQ04sV0FBVyxzREFBc0QsQ0FBQztNQUMzRixDQUFDLE1BQU07UUFDSCxJQUFJLENBQUNPLGdCQUFnQixDQUFDLENBQUM7TUFDM0I7SUFDSixDQUFDLEVBQUUsQ0FBQyxDQUFDO0VBQ1Q7O0VBRUE7QUFDSjtBQUNBO0FBQ0E7RUFDSUEsZ0JBQWdCQSxDQUFBLEVBQUc7SUFDZjtJQUNBRixPQUFPLENBQUNDLEdBQUcsQ0FBQyxJQUFJLElBQUksQ0FBQ04sV0FBVyxnQ0FBZ0MsQ0FBQztFQUNyRTs7RUFFQTtBQUNKO0FBQ0E7QUFDQTtFQUNJRSxrQkFBa0JBLENBQUEsRUFBRztJQUNqQjtJQUNBLElBQUksQ0FBQ1YsYUFBYSxDQUFDQyxpQkFBaUIsQ0FBQ2UsR0FBRyxDQUFDLElBQUksQ0FBQ1IsV0FBVyxDQUFDLEVBQUU7TUFDeEQsTUFBTVMsZUFBZSxHQUFJQyxLQUFLLElBQUs7UUFDL0JMLE9BQU8sQ0FBQ0ssS0FBSyxDQUFDLElBQUksSUFBSSxDQUFDVixXQUFXLHVCQUF1QixFQUFFVSxLQUFLLENBQUM7TUFDckUsQ0FBQztNQUNEbEIsYUFBYSxDQUFDQyxpQkFBaUIsQ0FBQ2tCLEdBQUcsQ0FBQyxJQUFJLENBQUNYLFdBQVcsRUFBRVMsZUFBZSxDQUFDO01BQ3RFYixPQUFPLENBQUNnQixFQUFFLENBQUMsbUJBQW1CLEVBQUVILGVBQWUsQ0FBQztJQUNwRDtJQUVBLElBQUksQ0FBQ2pCLGFBQWEsQ0FBQ0csa0JBQWtCLENBQUNhLEdBQUcsQ0FBQyxJQUFJLENBQUNSLFdBQVcsQ0FBQyxFQUFFO01BQ3pELE1BQU1hLGdCQUFnQixHQUFJQyxNQUFNLElBQUs7UUFDakNULE9BQU8sQ0FBQ0ssS0FBSyxDQUFDLElBQUksSUFBSSxDQUFDVixXQUFXLHdCQUF3QixFQUFFYyxNQUFNLENBQUM7TUFDdkUsQ0FBQztNQUNEdEIsYUFBYSxDQUFDRyxrQkFBa0IsQ0FBQ2dCLEdBQUcsQ0FBQyxJQUFJLENBQUNYLFdBQVcsRUFBRWEsZ0JBQWdCLENBQUM7TUFDeEVqQixPQUFPLENBQUNnQixFQUFFLENBQUMsb0JBQW9CLEVBQUVDLGdCQUFnQixDQUFDO0lBQ3REO0VBQ0o7O0VBRUE7QUFDSjtBQUNBO0FBQ0E7QUFDQTtFQUNJRSxlQUFlQSxDQUFDQyxPQUFPLEVBQUVDLE9BQU8sRUFBRTtJQUM5QjtJQUNBLElBQUk7TUFDQTtNQUNBO01BQ0EsTUFBTUMsVUFBVSxHQUFHNUIsT0FBTyxDQUFDNkIsWUFBWSxHQUFHLENBQUMsSUFBSTdCLE9BQU8sQ0FBQzhCLE9BQU8sSUFBSUMsTUFBTSxDQUFDQyxJQUFJLENBQUNoQyxPQUFPLENBQUM4QixPQUFPLENBQUM7TUFDOUYsTUFBTUcsbUJBQW1CLEdBQUdMLFVBQVUsSUFBSUEsVUFBVSxDQUFDTSxRQUFRLENBQUMsVUFBVVIsT0FBTyxFQUFFLENBQUM7TUFFbEYsSUFBSU8sbUJBQW1CLEVBQUU7UUFDckJsQixPQUFPLENBQUNDLEdBQUcsQ0FBQyxJQUFJLElBQUksQ0FBQ04sV0FBVyxpQkFBaUJnQixPQUFPLCtCQUErQixDQUFDO1FBQ3hGO01BQ0o7O01BRUE7TUFDQTFCLE9BQU8sQ0FBQ21DLE1BQU0sQ0FBQ1QsT0FBTyxFQUFFLE9BQU9VLEtBQUssRUFBRSxHQUFHQyxJQUFJLEtBQUs7UUFDOUMsSUFBSTtVQUNBLE9BQU8sTUFBTVYsT0FBTyxDQUFDUyxLQUFLLEVBQUUsR0FBR0MsSUFBSSxDQUFDO1FBQ3hDLENBQUMsQ0FBQyxPQUFPakIsS0FBSyxFQUFFO1VBQ1pMLE9BQU8sQ0FBQ0ssS0FBSyxDQUFDLElBQUksSUFBSSxDQUFDVixXQUFXLGNBQWNnQixPQUFPLEdBQUcsRUFBRU4sS0FBSyxDQUFDO1VBQ2xFLE1BQU1BLEtBQUssQ0FBQyxDQUFDO1FBQ2pCO01BQ0osQ0FBQyxDQUFDO01BQ0ZMLE9BQU8sQ0FBQ0MsR0FBRyxDQUFDLElBQUksSUFBSSxDQUFDTixXQUFXLDZCQUE2QmdCLE9BQU8sRUFBRSxDQUFDO0lBQzNFLENBQUMsQ0FBQyxPQUFPTixLQUFLLEVBQUU7TUFDWkwsT0FBTyxDQUFDSyxLQUFLLENBQUMsSUFBSSxJQUFJLENBQUNWLFdBQVcsbUNBQW1DZ0IsT0FBTyxHQUFHLEVBQUVOLEtBQUssQ0FBQztNQUN2RjtNQUNBcEIsT0FBTyxDQUFDbUMsTUFBTSxDQUFDVCxPQUFPLEVBQUUsT0FBT1UsS0FBSyxFQUFFLEdBQUdDLElBQUksS0FBSztRQUM5QyxJQUFJO1VBQ0EsT0FBTyxNQUFNVixPQUFPLENBQUNTLEtBQUssRUFBRSxHQUFHQyxJQUFJLENBQUM7UUFDeEMsQ0FBQyxDQUFDLE9BQU9qQixLQUFLLEVBQUU7VUFDWkwsT0FBTyxDQUFDSyxLQUFLLENBQUMsSUFBSSxJQUFJLENBQUNWLFdBQVcsY0FBY2dCLE9BQU8sR0FBRyxFQUFFTixLQUFLLENBQUM7VUFDbEUsTUFBTUEsS0FBSyxDQUFDLENBQUM7UUFDakI7TUFDSixDQUFDLENBQUM7SUFDTjtFQUNKOztFQUVBO0FBQ0o7QUFDQTtBQUNBO0VBQ0lrQixpQkFBaUJBLENBQUNaLE9BQU8sRUFBRTtJQUN2QjFCLE9BQU8sQ0FBQ3VDLGFBQWEsQ0FBQ2IsT0FBTyxDQUFDO0lBQzlCWCxPQUFPLENBQUNDLEdBQUcsQ0FBQyxJQUFJLElBQUksQ0FBQ04sV0FBVywrQkFBK0JnQixPQUFPLEVBQUUsQ0FBQztFQUM3RTtBQUNKO0FBRUFjLE1BQU0sQ0FBQ0MsT0FBTyxHQUFHakMsV0FBVyIsImlnbm9yZUxpc3QiOltdfQ==