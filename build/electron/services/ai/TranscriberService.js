"use strict";

/**
 * TranscriberService.js
 * Handles audio and video transcription in the Electron main process.
 * 
 * This service handles:
 * - Audio extraction from video files
 * - Audio file chunking for large files
 * - Transcription coordination with OpenAI
 * - Result aggregation and formatting
 * 
 * Related Files:
 * - BaseService.js: Parent class providing IPC handling
 * - OpenAIProxyService.js: For OpenAI API interactions
 * - FileStorageService.js: For temporary file management
 * - JobManagerService.js: For tracking transcription jobs
 */

const path = require('path');
const os = require('os');
const fs = require('fs-extra');
const {
  Buffer
} = require('node:buffer');
const ffmpeg = require('fluent-ffmpeg');
const {
  v4: uuidv4
} = require('uuid');
const BaseService = require('../BaseService');
const {
  createStore
} = require('../../utils/storeFactory');
// Import singleton dependencies by destructuring the exported object
const {
  instance: openAIProxyServiceInstance
} = require('./OpenAIProxyService');
const fileStorageServiceInstance = require('../storage/FileStorageService'); // Assuming this still exports instance directly

// Settings store for model selection
const settingsStore = createStore('settings');

// Max chunk size for audio files (25MB - OpenAI limit is 26MB)
const MAX_CHUNK_SIZE = 25 * 1024 * 1024;
class TranscriberService extends BaseService {
  constructor() {
    super();
    // Use the imported singleton instances directly
    this.openAIProxy = openAIProxyServiceInstance;
    this.fileStorage = fileStorageServiceInstance;
    this.activeJobs = new Map();
  }

  /**
   * Set up IPC handlers for transcription operations
   */
  setupIpcHandlers() {
    this.registerHandler('transcribe:start', this.handleTranscribeStart.bind(this));
    this.registerHandler('transcribe:status', this.handleTranscribeStatus.bind(this));
    this.registerHandler('transcribe:cancel', this.handleTranscribeCancel.bind(this));
  }

  /**
   * Handle transcription start request
   * @param {Electron.IpcMainInvokeEvent} event - IPC event
   * @param {Object} request - Transcription request details
   */
  async handleTranscribeStart(event, {
    filePath,
    options = {}
  }) {
    try {
      const jobId = uuidv4();
      const tempDir = await this.fileStorage.createTempDir('transcription');
      this.activeJobs.set(jobId, {
        status: 'preparing',
        progress: 0,
        filePath,
        tempDir,
        // Get window only if event and sender exist (called via IPC)
        window: event && event.sender ? event.sender.getOwnerBrowserWindow() : null
      });

      // Start transcription process
      this.processTranscription(jobId, filePath, options).catch(error => {
        console.error(`[TranscriberService] Transcription failed for job ${jobId}:`, error);
        this.updateJobStatus(jobId, 'failed', {
          error: error.message
        });
      });
      return {
        jobId
      };
    } catch (error) {
      console.error('[TranscriberService] Failed to start transcription:', error);
      throw error;
    }
  }

  /**
   * Handle transcription status request
   * @param {Electron.IpcMainInvokeEvent} event - IPC event
   * @param {Object} request - Status request details
   */
  async handleTranscribeStatus(event, {
    jobId
  }) {
    const job = this.activeJobs.get(jobId);
    return job || {
      status: 'not_found'
    };
  }

  /**
   * Handle transcription cancellation request
   * @param {Electron.IpcMainInvokeEvent} event - IPC event
   * @param {Object} request - Cancellation request details
   */
  async handleTranscribeCancel(event, {
    jobId
  }) {
    const job = this.activeJobs.get(jobId);
    if (job) {
      job.status = 'cancelled';
      // Clean up temporary files
      await fs.remove(job.tempDir);
      this.activeJobs.delete(jobId);
    }
    return {
      success: true
    };
  }

  /**
   * Process transcription job
   * @param {string} jobId - Job identifier
   * @param {string} filePath - Path to media file
   * @param {Object} options - Transcription options
   */
  async processTranscription(jobId, filePath, options) {
    try {
      this.updateJobStatus(jobId, 'extracting_audio');
      const audioPath = await this.extractAudio(filePath, jobId);
      this.updateJobStatus(jobId, 'chunking');
      const chunks = await this.createAudioChunks(audioPath, jobId);
      this.updateJobStatus(jobId, 'transcribing', {
        total: chunks.length
      });
      const transcriptions = await this.transcribeChunks(jobId, chunks, options);
      this.updateJobStatus(jobId, 'combining');
      const result = this.combineTranscriptions(transcriptions);

      // Clean up temp files
      await fs.remove(this.activeJobs.get(jobId).tempDir);
      this.updateJobStatus(jobId, 'completed', {
        result
      });
    } catch (error) {
      console.error('[TranscriberService] Transcription processing failed:', error);
      throw error;
    }
  }

  /**
   * Extract audio from media file
   * @param {string} filePath - Path to media file
   * @param {string} jobId - Job identifier
   * @returns {Promise<string>} Path to extracted audio
   */
  async extractAudio(filePath, jobId) {
    const job = this.activeJobs.get(jobId);
    const outputPath = path.join(job.tempDir, 'audio.mp3');
    return new Promise((resolve, reject) => {
      ffmpeg(filePath).toFormat('mp3').on('progress', progress => {
        this.updateJobStatus(jobId, 'extracting_audio', {
          progress: Math.round(progress.percent || 0)
        });
      }).on('end', () => resolve(outputPath)).on('error', error => reject(error)).save(outputPath);
    });
  }

  /**
   * Create audio chunks for large files
   * @param {string} audioPath - Path to audio file
   * @param {string} jobId - Job identifier
   * @returns {Promise<string[]>} Array of chunk file paths
   */
  async createAudioChunks(audioPath, jobId) {
    const job = this.activeJobs.get(jobId);
    const stats = await fs.stat(audioPath);
    if (stats.size <= MAX_CHUNK_SIZE) {
      return [audioPath];
    }
    const duration = await this.getAudioDuration(audioPath);
    const chunkDuration = Math.ceil(duration * MAX_CHUNK_SIZE / stats.size);
    const chunks = [];
    for (let start = 0; start < duration; start += chunkDuration) {
      const chunkPath = path.join(job.tempDir, `chunk_${start}.mp3`);
      await this.extractAudioChunk(audioPath, chunkPath, start, chunkDuration);
      chunks.push(chunkPath);
      this.updateJobStatus(jobId, 'chunking', {
        progress: Math.round((start + chunkDuration) / duration * 100)
      });
    }
    return chunks;
  }

  /**
   * Get audio file duration
   * @param {string} audioPath - Path to audio file
   * @returns {Promise<number>} Duration in seconds
   */
  async getAudioDuration(audioPath) {
    return new Promise((resolve, reject) => {
      ffmpeg.ffprobe(audioPath, (err, metadata) => {
        if (err) reject(err);else resolve(metadata.format.duration);
      });
    });
  }

  /**
   * Extract audio chunk
   * @param {string} inputPath - Input audio path
   * @param {string} outputPath - Output chunk path
   * @param {number} start - Start time in seconds
   * @param {number} duration - Chunk duration in seconds
   */
  async extractAudioChunk(inputPath, outputPath, start, duration) {
    return new Promise((resolve, reject) => {
      ffmpeg(inputPath).setStartTime(start).setDuration(duration).output(outputPath).on('end', resolve).on('error', reject).run();
    });
  }

  /**
   * Transcribe audio chunks
   * @param {string} jobId - Job identifier
   * @param {string[]} chunks - Array of chunk paths
   * @param {Object} options - Transcription options
   * @returns {Promise<Object[]>} Array of transcription results
   */
  async transcribeChunks(jobId, chunks, options) {
    const results = [];
    let completed = 0;

    // Get transcription model from settings or use default
    const model = settingsStore.get('transcription.model', 'whisper');
    console.log(`[TranscriberService] Using transcription model: ${model}`);
    for (const chunk of chunks) {
      const result = await this.openAIProxy.handleTranscribe(null, {
        audioPath: chunk,
        model,
        ...options
      });
      results.push(result);
      completed++;
      this.updateJobStatus(jobId, 'transcribing', {
        progress: Math.round(completed / chunks.length * 100),
        completed,
        total: chunks.length,
        model
      });
    }
    return results;
  }

  /**
   * Combine chunk transcriptions
   * @param {Object[]} transcriptions - Array of transcription results
   * @returns {Object} Combined result
   */
  combineTranscriptions(transcriptions) {
    let combinedText = transcriptions.map(t => t.text.trim()).join('\n');
    return {
      text: combinedText,
      language: transcriptions[0].language
    };
  }

  /**
   * Update job status and notify renderer
   * @param {string} jobId - Job identifier
   * @param {string} status - New status
   * @param {Object} details - Additional details
   */
  updateJobStatus(jobId, status, details = {}) {
    const job = this.activeJobs.get(jobId);
    if (job) {
      job.status = status;
      Object.assign(job, details);
      if (job.window) {
        job.window.webContents.send('transcribe:progress', {
          jobId,
          status,
          ...details
        });
      }
    }
  }

  /**
   * Clean up job resources
   * @param {string} jobId - Job identifier
   */
  async cleanupJob(jobId) {
    const job = this.activeJobs.get(jobId);
    if (job) {
      await fs.remove(job.tempDir);
      this.activeJobs.delete(jobId);
    }
  }
}

// Create and export the singleton instance
const transcriberServiceInstance = new TranscriberService();
module.exports = transcriberServiceInstance;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJwYXRoIiwicmVxdWlyZSIsIm9zIiwiZnMiLCJCdWZmZXIiLCJmZm1wZWciLCJ2NCIsInV1aWR2NCIsIkJhc2VTZXJ2aWNlIiwiY3JlYXRlU3RvcmUiLCJpbnN0YW5jZSIsIm9wZW5BSVByb3h5U2VydmljZUluc3RhbmNlIiwiZmlsZVN0b3JhZ2VTZXJ2aWNlSW5zdGFuY2UiLCJzZXR0aW5nc1N0b3JlIiwiTUFYX0NIVU5LX1NJWkUiLCJUcmFuc2NyaWJlclNlcnZpY2UiLCJjb25zdHJ1Y3RvciIsIm9wZW5BSVByb3h5IiwiZmlsZVN0b3JhZ2UiLCJhY3RpdmVKb2JzIiwiTWFwIiwic2V0dXBJcGNIYW5kbGVycyIsInJlZ2lzdGVySGFuZGxlciIsImhhbmRsZVRyYW5zY3JpYmVTdGFydCIsImJpbmQiLCJoYW5kbGVUcmFuc2NyaWJlU3RhdHVzIiwiaGFuZGxlVHJhbnNjcmliZUNhbmNlbCIsImV2ZW50IiwiZmlsZVBhdGgiLCJvcHRpb25zIiwiam9iSWQiLCJ0ZW1wRGlyIiwiY3JlYXRlVGVtcERpciIsInNldCIsInN0YXR1cyIsInByb2dyZXNzIiwid2luZG93Iiwic2VuZGVyIiwiZ2V0T3duZXJCcm93c2VyV2luZG93IiwicHJvY2Vzc1RyYW5zY3JpcHRpb24iLCJjYXRjaCIsImVycm9yIiwiY29uc29sZSIsInVwZGF0ZUpvYlN0YXR1cyIsIm1lc3NhZ2UiLCJqb2IiLCJnZXQiLCJyZW1vdmUiLCJkZWxldGUiLCJzdWNjZXNzIiwiYXVkaW9QYXRoIiwiZXh0cmFjdEF1ZGlvIiwiY2h1bmtzIiwiY3JlYXRlQXVkaW9DaHVua3MiLCJ0b3RhbCIsImxlbmd0aCIsInRyYW5zY3JpcHRpb25zIiwidHJhbnNjcmliZUNodW5rcyIsInJlc3VsdCIsImNvbWJpbmVUcmFuc2NyaXB0aW9ucyIsIm91dHB1dFBhdGgiLCJqb2luIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJ0b0Zvcm1hdCIsIm9uIiwiTWF0aCIsInJvdW5kIiwicGVyY2VudCIsInNhdmUiLCJzdGF0cyIsInN0YXQiLCJzaXplIiwiZHVyYXRpb24iLCJnZXRBdWRpb0R1cmF0aW9uIiwiY2h1bmtEdXJhdGlvbiIsImNlaWwiLCJzdGFydCIsImNodW5rUGF0aCIsImV4dHJhY3RBdWRpb0NodW5rIiwicHVzaCIsImZmcHJvYmUiLCJlcnIiLCJtZXRhZGF0YSIsImZvcm1hdCIsImlucHV0UGF0aCIsInNldFN0YXJ0VGltZSIsInNldER1cmF0aW9uIiwib3V0cHV0IiwicnVuIiwicmVzdWx0cyIsImNvbXBsZXRlZCIsIm1vZGVsIiwibG9nIiwiY2h1bmsiLCJoYW5kbGVUcmFuc2NyaWJlIiwiY29tYmluZWRUZXh0IiwibWFwIiwidCIsInRleHQiLCJ0cmltIiwibGFuZ3VhZ2UiLCJkZXRhaWxzIiwiT2JqZWN0IiwiYXNzaWduIiwid2ViQ29udGVudHMiLCJzZW5kIiwiY2xlYW51cEpvYiIsInRyYW5zY3JpYmVyU2VydmljZUluc3RhbmNlIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9lbGVjdHJvbi9zZXJ2aWNlcy9haS9UcmFuc2NyaWJlclNlcnZpY2UuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIFRyYW5zY3JpYmVyU2VydmljZS5qc1xyXG4gKiBIYW5kbGVzIGF1ZGlvIGFuZCB2aWRlbyB0cmFuc2NyaXB0aW9uIGluIHRoZSBFbGVjdHJvbiBtYWluIHByb2Nlc3MuXHJcbiAqIFxyXG4gKiBUaGlzIHNlcnZpY2UgaGFuZGxlczpcclxuICogLSBBdWRpbyBleHRyYWN0aW9uIGZyb20gdmlkZW8gZmlsZXNcclxuICogLSBBdWRpbyBmaWxlIGNodW5raW5nIGZvciBsYXJnZSBmaWxlc1xyXG4gKiAtIFRyYW5zY3JpcHRpb24gY29vcmRpbmF0aW9uIHdpdGggT3BlbkFJXHJcbiAqIC0gUmVzdWx0IGFnZ3JlZ2F0aW9uIGFuZCBmb3JtYXR0aW5nXHJcbiAqIFxyXG4gKiBSZWxhdGVkIEZpbGVzOlxyXG4gKiAtIEJhc2VTZXJ2aWNlLmpzOiBQYXJlbnQgY2xhc3MgcHJvdmlkaW5nIElQQyBoYW5kbGluZ1xyXG4gKiAtIE9wZW5BSVByb3h5U2VydmljZS5qczogRm9yIE9wZW5BSSBBUEkgaW50ZXJhY3Rpb25zXHJcbiAqIC0gRmlsZVN0b3JhZ2VTZXJ2aWNlLmpzOiBGb3IgdGVtcG9yYXJ5IGZpbGUgbWFuYWdlbWVudFxyXG4gKiAtIEpvYk1hbmFnZXJTZXJ2aWNlLmpzOiBGb3IgdHJhY2tpbmcgdHJhbnNjcmlwdGlvbiBqb2JzXHJcbiAqL1xyXG5cclxuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcclxuY29uc3Qgb3MgPSByZXF1aXJlKCdvcycpO1xyXG5jb25zdCBmcyA9IHJlcXVpcmUoJ2ZzLWV4dHJhJyk7XHJcbmNvbnN0IHsgQnVmZmVyIH0gPSByZXF1aXJlKCdub2RlOmJ1ZmZlcicpO1xyXG5jb25zdCBmZm1wZWcgPSByZXF1aXJlKCdmbHVlbnQtZmZtcGVnJyk7XHJcbmNvbnN0IHsgdjQ6IHV1aWR2NCB9ID0gcmVxdWlyZSgndXVpZCcpO1xyXG5jb25zdCBCYXNlU2VydmljZSA9IHJlcXVpcmUoJy4uL0Jhc2VTZXJ2aWNlJyk7XHJcbmNvbnN0IHsgY3JlYXRlU3RvcmUgfSA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL3N0b3JlRmFjdG9yeScpO1xyXG4vLyBJbXBvcnQgc2luZ2xldG9uIGRlcGVuZGVuY2llcyBieSBkZXN0cnVjdHVyaW5nIHRoZSBleHBvcnRlZCBvYmplY3RcclxuY29uc3QgeyBpbnN0YW5jZTogb3BlbkFJUHJveHlTZXJ2aWNlSW5zdGFuY2UgfSA9IHJlcXVpcmUoJy4vT3BlbkFJUHJveHlTZXJ2aWNlJyk7IFxyXG5jb25zdCBmaWxlU3RvcmFnZVNlcnZpY2VJbnN0YW5jZSA9IHJlcXVpcmUoJy4uL3N0b3JhZ2UvRmlsZVN0b3JhZ2VTZXJ2aWNlJyk7IC8vIEFzc3VtaW5nIHRoaXMgc3RpbGwgZXhwb3J0cyBpbnN0YW5jZSBkaXJlY3RseVxyXG5cclxuLy8gU2V0dGluZ3Mgc3RvcmUgZm9yIG1vZGVsIHNlbGVjdGlvblxyXG5jb25zdCBzZXR0aW5nc1N0b3JlID0gY3JlYXRlU3RvcmUoJ3NldHRpbmdzJyk7XHJcblxyXG4vLyBNYXggY2h1bmsgc2l6ZSBmb3IgYXVkaW8gZmlsZXMgKDI1TUIgLSBPcGVuQUkgbGltaXQgaXMgMjZNQilcclxuY29uc3QgTUFYX0NIVU5LX1NJWkUgPSAyNSAqIDEwMjQgKiAxMDI0O1xyXG5cclxuY2xhc3MgVHJhbnNjcmliZXJTZXJ2aWNlIGV4dGVuZHMgQmFzZVNlcnZpY2Uge1xyXG4gICAgY29uc3RydWN0b3IoKSB7IFxyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgLy8gVXNlIHRoZSBpbXBvcnRlZCBzaW5nbGV0b24gaW5zdGFuY2VzIGRpcmVjdGx5XHJcbiAgICAgICAgdGhpcy5vcGVuQUlQcm94eSA9IG9wZW5BSVByb3h5U2VydmljZUluc3RhbmNlOyBcclxuICAgICAgICB0aGlzLmZpbGVTdG9yYWdlID0gZmlsZVN0b3JhZ2VTZXJ2aWNlSW5zdGFuY2U7IFxyXG4gICAgICAgIHRoaXMuYWN0aXZlSm9icyA9IG5ldyBNYXAoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCB1cCBJUEMgaGFuZGxlcnMgZm9yIHRyYW5zY3JpcHRpb24gb3BlcmF0aW9uc1xyXG4gICAgICovXHJcbiAgICBzZXR1cElwY0hhbmRsZXJzKCkge1xyXG4gICAgICAgIHRoaXMucmVnaXN0ZXJIYW5kbGVyKCd0cmFuc2NyaWJlOnN0YXJ0JywgdGhpcy5oYW5kbGVUcmFuc2NyaWJlU3RhcnQuYmluZCh0aGlzKSk7XHJcbiAgICAgICAgdGhpcy5yZWdpc3RlckhhbmRsZXIoJ3RyYW5zY3JpYmU6c3RhdHVzJywgdGhpcy5oYW5kbGVUcmFuc2NyaWJlU3RhdHVzLmJpbmQodGhpcykpO1xyXG4gICAgICAgIHRoaXMucmVnaXN0ZXJIYW5kbGVyKCd0cmFuc2NyaWJlOmNhbmNlbCcsIHRoaXMuaGFuZGxlVHJhbnNjcmliZUNhbmNlbC5iaW5kKHRoaXMpKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEhhbmRsZSB0cmFuc2NyaXB0aW9uIHN0YXJ0IHJlcXVlc3RcclxuICAgICAqIEBwYXJhbSB7RWxlY3Ryb24uSXBjTWFpbkludm9rZUV2ZW50fSBldmVudCAtIElQQyBldmVudFxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHJlcXVlc3QgLSBUcmFuc2NyaXB0aW9uIHJlcXVlc3QgZGV0YWlsc1xyXG4gICAgICovXHJcbiAgICBhc3luYyBoYW5kbGVUcmFuc2NyaWJlU3RhcnQoZXZlbnQsIHsgZmlsZVBhdGgsIG9wdGlvbnMgPSB7fSB9KSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgY29uc3Qgam9iSWQgPSB1dWlkdjQoKTtcclxuICAgICAgICAgICAgY29uc3QgdGVtcERpciA9IGF3YWl0IHRoaXMuZmlsZVN0b3JhZ2UuY3JlYXRlVGVtcERpcigndHJhbnNjcmlwdGlvbicpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgdGhpcy5hY3RpdmVKb2JzLnNldChqb2JJZCwge1xyXG4gICAgICAgICAgICAgICAgc3RhdHVzOiAncHJlcGFyaW5nJyxcclxuICAgICAgICAgICAgICAgIHByb2dyZXNzOiAwLFxyXG4gICAgICAgICAgICAgICAgZmlsZVBhdGgsXHJcbiAgICAgICAgICAgICAgICB0ZW1wRGlyLFxyXG4gICAgICAgICAgICAgICAgLy8gR2V0IHdpbmRvdyBvbmx5IGlmIGV2ZW50IGFuZCBzZW5kZXIgZXhpc3QgKGNhbGxlZCB2aWEgSVBDKVxyXG4gICAgICAgICAgICAgICAgd2luZG93OiBldmVudCAmJiBldmVudC5zZW5kZXIgPyBldmVudC5zZW5kZXIuZ2V0T3duZXJCcm93c2VyV2luZG93KCkgOiBudWxsXHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgLy8gU3RhcnQgdHJhbnNjcmlwdGlvbiBwcm9jZXNzXHJcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc1RyYW5zY3JpcHRpb24oam9iSWQsIGZpbGVQYXRoLCBvcHRpb25zKS5jYXRjaChlcnJvciA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBbVHJhbnNjcmliZXJTZXJ2aWNlXSBUcmFuc2NyaXB0aW9uIGZhaWxlZCBmb3Igam9iICR7am9iSWR9OmAsIGVycm9yKTtcclxuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlSm9iU3RhdHVzKGpvYklkLCAnZmFpbGVkJywgeyBlcnJvcjogZXJyb3IubWVzc2FnZSB9KTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4geyBqb2JJZCB9O1xyXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1tUcmFuc2NyaWJlclNlcnZpY2VdIEZhaWxlZCB0byBzdGFydCB0cmFuc2NyaXB0aW9uOicsIGVycm9yKTtcclxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSGFuZGxlIHRyYW5zY3JpcHRpb24gc3RhdHVzIHJlcXVlc3RcclxuICAgICAqIEBwYXJhbSB7RWxlY3Ryb24uSXBjTWFpbkludm9rZUV2ZW50fSBldmVudCAtIElQQyBldmVudFxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHJlcXVlc3QgLSBTdGF0dXMgcmVxdWVzdCBkZXRhaWxzXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIGhhbmRsZVRyYW5zY3JpYmVTdGF0dXMoZXZlbnQsIHsgam9iSWQgfSkge1xyXG4gICAgICAgIGNvbnN0IGpvYiA9IHRoaXMuYWN0aXZlSm9icy5nZXQoam9iSWQpO1xyXG4gICAgICAgIHJldHVybiBqb2IgfHwgeyBzdGF0dXM6ICdub3RfZm91bmQnIH07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBIYW5kbGUgdHJhbnNjcmlwdGlvbiBjYW5jZWxsYXRpb24gcmVxdWVzdFxyXG4gICAgICogQHBhcmFtIHtFbGVjdHJvbi5JcGNNYWluSW52b2tlRXZlbnR9IGV2ZW50IC0gSVBDIGV2ZW50XHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcmVxdWVzdCAtIENhbmNlbGxhdGlvbiByZXF1ZXN0IGRldGFpbHNcclxuICAgICAqL1xyXG4gICAgYXN5bmMgaGFuZGxlVHJhbnNjcmliZUNhbmNlbChldmVudCwgeyBqb2JJZCB9KSB7XHJcbiAgICAgICAgY29uc3Qgam9iID0gdGhpcy5hY3RpdmVKb2JzLmdldChqb2JJZCk7XHJcbiAgICAgICAgaWYgKGpvYikge1xyXG4gICAgICAgICAgICBqb2Iuc3RhdHVzID0gJ2NhbmNlbGxlZCc7XHJcbiAgICAgICAgICAgIC8vIENsZWFuIHVwIHRlbXBvcmFyeSBmaWxlc1xyXG4gICAgICAgICAgICBhd2FpdCBmcy5yZW1vdmUoam9iLnRlbXBEaXIpO1xyXG4gICAgICAgICAgICB0aGlzLmFjdGl2ZUpvYnMuZGVsZXRlKGpvYklkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUHJvY2VzcyB0cmFuc2NyaXB0aW9uIGpvYlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGpvYklkIC0gSm9iIGlkZW50aWZpZXJcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlUGF0aCAtIFBhdGggdG8gbWVkaWEgZmlsZVxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBUcmFuc2NyaXB0aW9uIG9wdGlvbnNcclxuICAgICAqL1xyXG4gICAgYXN5bmMgcHJvY2Vzc1RyYW5zY3JpcHRpb24oam9iSWQsIGZpbGVQYXRoLCBvcHRpb25zKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVKb2JTdGF0dXMoam9iSWQsICdleHRyYWN0aW5nX2F1ZGlvJyk7XHJcbiAgICAgICAgICAgIGNvbnN0IGF1ZGlvUGF0aCA9IGF3YWl0IHRoaXMuZXh0cmFjdEF1ZGlvKGZpbGVQYXRoLCBqb2JJZCk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUpvYlN0YXR1cyhqb2JJZCwgJ2NodW5raW5nJyk7XHJcbiAgICAgICAgICAgIGNvbnN0IGNodW5rcyA9IGF3YWl0IHRoaXMuY3JlYXRlQXVkaW9DaHVua3MoYXVkaW9QYXRoLCBqb2JJZCk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUpvYlN0YXR1cyhqb2JJZCwgJ3RyYW5zY3JpYmluZycsIHsgdG90YWw6IGNodW5rcy5sZW5ndGggfSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zY3JpcHRpb25zID0gYXdhaXQgdGhpcy50cmFuc2NyaWJlQ2h1bmtzKGpvYklkLCBjaHVua3MsIG9wdGlvbnMpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy51cGRhdGVKb2JTdGF0dXMoam9iSWQsICdjb21iaW5pbmcnKTtcclxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5jb21iaW5lVHJhbnNjcmlwdGlvbnModHJhbnNjcmlwdGlvbnMpO1xyXG5cclxuICAgICAgICAgICAgLy8gQ2xlYW4gdXAgdGVtcCBmaWxlc1xyXG4gICAgICAgICAgICBhd2FpdCBmcy5yZW1vdmUodGhpcy5hY3RpdmVKb2JzLmdldChqb2JJZCkudGVtcERpcik7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUpvYlN0YXR1cyhqb2JJZCwgJ2NvbXBsZXRlZCcsIHsgcmVzdWx0IH0pO1xyXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1tUcmFuc2NyaWJlclNlcnZpY2VdIFRyYW5zY3JpcHRpb24gcHJvY2Vzc2luZyBmYWlsZWQ6JywgZXJyb3IpO1xyXG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBFeHRyYWN0IGF1ZGlvIGZyb20gbWVkaWEgZmlsZVxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZpbGVQYXRoIC0gUGF0aCB0byBtZWRpYSBmaWxlXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gam9iSWQgLSBKb2IgaWRlbnRpZmllclxyXG4gICAgICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nPn0gUGF0aCB0byBleHRyYWN0ZWQgYXVkaW9cclxuICAgICAqL1xyXG4gICAgYXN5bmMgZXh0cmFjdEF1ZGlvKGZpbGVQYXRoLCBqb2JJZCkge1xyXG4gICAgICAgIGNvbnN0IGpvYiA9IHRoaXMuYWN0aXZlSm9icy5nZXQoam9iSWQpO1xyXG4gICAgICAgIGNvbnN0IG91dHB1dFBhdGggPSBwYXRoLmpvaW4oam9iLnRlbXBEaXIsICdhdWRpby5tcDMnKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgZmZtcGVnKGZpbGVQYXRoKVxyXG4gICAgICAgICAgICAgICAgLnRvRm9ybWF0KCdtcDMnKVxyXG4gICAgICAgICAgICAgICAgLm9uKCdwcm9ncmVzcycsIHByb2dyZXNzID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUpvYlN0YXR1cyhqb2JJZCwgJ2V4dHJhY3RpbmdfYXVkaW8nLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2dyZXNzOiBNYXRoLnJvdW5kKHByb2dyZXNzLnBlcmNlbnQgfHwgMClcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAub24oJ2VuZCcsICgpID0+IHJlc29sdmUob3V0cHV0UGF0aCkpXHJcbiAgICAgICAgICAgICAgICAub24oJ2Vycm9yJywgZXJyb3IgPT4gcmVqZWN0KGVycm9yKSlcclxuICAgICAgICAgICAgICAgIC5zYXZlKG91dHB1dFBhdGgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIGF1ZGlvIGNodW5rcyBmb3IgbGFyZ2UgZmlsZXNcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhdWRpb1BhdGggLSBQYXRoIHRvIGF1ZGlvIGZpbGVcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBqb2JJZCAtIEpvYiBpZGVudGlmaWVyXHJcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmdbXT59IEFycmF5IG9mIGNodW5rIGZpbGUgcGF0aHNcclxuICAgICAqL1xyXG4gICAgYXN5bmMgY3JlYXRlQXVkaW9DaHVua3MoYXVkaW9QYXRoLCBqb2JJZCkge1xyXG4gICAgICAgIGNvbnN0IGpvYiA9IHRoaXMuYWN0aXZlSm9icy5nZXQoam9iSWQpO1xyXG4gICAgICAgIGNvbnN0IHN0YXRzID0gYXdhaXQgZnMuc3RhdChhdWRpb1BhdGgpO1xyXG5cclxuICAgICAgICBpZiAoc3RhdHMuc2l6ZSA8PSBNQVhfQ0hVTktfU0laRSkge1xyXG4gICAgICAgICAgICByZXR1cm4gW2F1ZGlvUGF0aF07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBkdXJhdGlvbiA9IGF3YWl0IHRoaXMuZ2V0QXVkaW9EdXJhdGlvbihhdWRpb1BhdGgpO1xyXG4gICAgICAgIGNvbnN0IGNodW5rRHVyYXRpb24gPSBNYXRoLmNlaWwoKGR1cmF0aW9uICogTUFYX0NIVU5LX1NJWkUpIC8gc3RhdHMuc2l6ZSk7XHJcbiAgICAgICAgY29uc3QgY2h1bmtzID0gW107XHJcblxyXG4gICAgICAgIGZvciAobGV0IHN0YXJ0ID0gMDsgc3RhcnQgPCBkdXJhdGlvbjsgc3RhcnQgKz0gY2h1bmtEdXJhdGlvbikge1xyXG4gICAgICAgICAgICBjb25zdCBjaHVua1BhdGggPSBwYXRoLmpvaW4oam9iLnRlbXBEaXIsIGBjaHVua18ke3N0YXJ0fS5tcDNgKTtcclxuICAgICAgICAgICAgYXdhaXQgdGhpcy5leHRyYWN0QXVkaW9DaHVuayhhdWRpb1BhdGgsIGNodW5rUGF0aCwgc3RhcnQsIGNodW5rRHVyYXRpb24pO1xyXG4gICAgICAgICAgICBjaHVua3MucHVzaChjaHVua1BhdGgpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy51cGRhdGVKb2JTdGF0dXMoam9iSWQsICdjaHVua2luZycsIHtcclxuICAgICAgICAgICAgICAgIHByb2dyZXNzOiBNYXRoLnJvdW5kKChzdGFydCArIGNodW5rRHVyYXRpb24pIC8gZHVyYXRpb24gKiAxMDApXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGNodW5rcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCBhdWRpbyBmaWxlIGR1cmF0aW9uXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXVkaW9QYXRoIC0gUGF0aCB0byBhdWRpbyBmaWxlXHJcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxudW1iZXI+fSBEdXJhdGlvbiBpbiBzZWNvbmRzXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIGdldEF1ZGlvRHVyYXRpb24oYXVkaW9QYXRoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgZmZtcGVnLmZmcHJvYmUoYXVkaW9QYXRoLCAoZXJyLCBtZXRhZGF0YSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVycikgcmVqZWN0KGVycik7XHJcbiAgICAgICAgICAgICAgICBlbHNlIHJlc29sdmUobWV0YWRhdGEuZm9ybWF0LmR1cmF0aW9uKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBFeHRyYWN0IGF1ZGlvIGNodW5rXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaW5wdXRQYXRoIC0gSW5wdXQgYXVkaW8gcGF0aFxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG91dHB1dFBhdGggLSBPdXRwdXQgY2h1bmsgcGF0aFxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IC0gU3RhcnQgdGltZSBpbiBzZWNvbmRzXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZHVyYXRpb24gLSBDaHVuayBkdXJhdGlvbiBpbiBzZWNvbmRzXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIGV4dHJhY3RBdWRpb0NodW5rKGlucHV0UGF0aCwgb3V0cHV0UGF0aCwgc3RhcnQsIGR1cmF0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgZmZtcGVnKGlucHV0UGF0aClcclxuICAgICAgICAgICAgICAgIC5zZXRTdGFydFRpbWUoc3RhcnQpXHJcbiAgICAgICAgICAgICAgICAuc2V0RHVyYXRpb24oZHVyYXRpb24pXHJcbiAgICAgICAgICAgICAgICAub3V0cHV0KG91dHB1dFBhdGgpXHJcbiAgICAgICAgICAgICAgICAub24oJ2VuZCcsIHJlc29sdmUpXHJcbiAgICAgICAgICAgICAgICAub24oJ2Vycm9yJywgcmVqZWN0KVxyXG4gICAgICAgICAgICAgICAgLnJ1bigpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVHJhbnNjcmliZSBhdWRpbyBjaHVua3NcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBqb2JJZCAtIEpvYiBpZGVudGlmaWVyXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBjaHVua3MgLSBBcnJheSBvZiBjaHVuayBwYXRoc1xyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBUcmFuc2NyaXB0aW9uIG9wdGlvbnNcclxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdFtdPn0gQXJyYXkgb2YgdHJhbnNjcmlwdGlvbiByZXN1bHRzXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIHRyYW5zY3JpYmVDaHVua3Moam9iSWQsIGNodW5rcywgb3B0aW9ucykge1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcclxuICAgICAgICBsZXQgY29tcGxldGVkID0gMDtcclxuXHJcbiAgICAgICAgLy8gR2V0IHRyYW5zY3JpcHRpb24gbW9kZWwgZnJvbSBzZXR0aW5ncyBvciB1c2UgZGVmYXVsdFxyXG4gICAgICAgIGNvbnN0IG1vZGVsID0gc2V0dGluZ3NTdG9yZS5nZXQoJ3RyYW5zY3JpcHRpb24ubW9kZWwnLCAnd2hpc3BlcicpO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGBbVHJhbnNjcmliZXJTZXJ2aWNlXSBVc2luZyB0cmFuc2NyaXB0aW9uIG1vZGVsOiAke21vZGVsfWApO1xyXG5cclxuICAgICAgICBmb3IgKGNvbnN0IGNodW5rIG9mIGNodW5rcykge1xyXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLm9wZW5BSVByb3h5LmhhbmRsZVRyYW5zY3JpYmUobnVsbCwge1xyXG4gICAgICAgICAgICAgICAgYXVkaW9QYXRoOiBjaHVuayxcclxuICAgICAgICAgICAgICAgIG1vZGVsLFxyXG4gICAgICAgICAgICAgICAgLi4ub3B0aW9uc1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaChyZXN1bHQpO1xyXG4gICAgICAgICAgICBjb21wbGV0ZWQrKztcclxuXHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlSm9iU3RhdHVzKGpvYklkLCAndHJhbnNjcmliaW5nJywge1xyXG4gICAgICAgICAgICAgICAgcHJvZ3Jlc3M6IE1hdGgucm91bmQoKGNvbXBsZXRlZCAvIGNodW5rcy5sZW5ndGgpICogMTAwKSxcclxuICAgICAgICAgICAgICAgIGNvbXBsZXRlZCxcclxuICAgICAgICAgICAgICAgIHRvdGFsOiBjaHVua3MubGVuZ3RoLFxyXG4gICAgICAgICAgICAgICAgbW9kZWxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gcmVzdWx0cztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbWJpbmUgY2h1bmsgdHJhbnNjcmlwdGlvbnNcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IHRyYW5zY3JpcHRpb25zIC0gQXJyYXkgb2YgdHJhbnNjcmlwdGlvbiByZXN1bHRzXHJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBDb21iaW5lZCByZXN1bHRcclxuICAgICAqL1xyXG4gICAgY29tYmluZVRyYW5zY3JpcHRpb25zKHRyYW5zY3JpcHRpb25zKSB7XHJcbiAgICAgICAgbGV0IGNvbWJpbmVkVGV4dCA9IHRyYW5zY3JpcHRpb25zXHJcbiAgICAgICAgICAgIC5tYXAodCA9PiB0LnRleHQudHJpbSgpKVxyXG4gICAgICAgICAgICAuam9pbignXFxuJyk7XHJcblxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHRleHQ6IGNvbWJpbmVkVGV4dCxcclxuICAgICAgICAgICAgbGFuZ3VhZ2U6IHRyYW5zY3JpcHRpb25zWzBdLmxhbmd1YWdlXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZSBqb2Igc3RhdHVzIGFuZCBub3RpZnkgcmVuZGVyZXJcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBqb2JJZCAtIEpvYiBpZGVudGlmaWVyXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RhdHVzIC0gTmV3IHN0YXR1c1xyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRldGFpbHMgLSBBZGRpdGlvbmFsIGRldGFpbHNcclxuICAgICAqL1xyXG4gICAgdXBkYXRlSm9iU3RhdHVzKGpvYklkLCBzdGF0dXMsIGRldGFpbHMgPSB7fSkge1xyXG4gICAgICAgIGNvbnN0IGpvYiA9IHRoaXMuYWN0aXZlSm9icy5nZXQoam9iSWQpO1xyXG4gICAgICAgIGlmIChqb2IpIHtcclxuICAgICAgICAgICAgam9iLnN0YXR1cyA9IHN0YXR1cztcclxuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihqb2IsIGRldGFpbHMpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGpvYi53aW5kb3cpIHtcclxuICAgICAgICAgICAgICAgIGpvYi53aW5kb3cud2ViQ29udGVudHMuc2VuZCgndHJhbnNjcmliZTpwcm9ncmVzcycsIHtcclxuICAgICAgICAgICAgICAgICAgICBqb2JJZCxcclxuICAgICAgICAgICAgICAgICAgICBzdGF0dXMsXHJcbiAgICAgICAgICAgICAgICAgICAgLi4uZGV0YWlsc1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDbGVhbiB1cCBqb2IgcmVzb3VyY2VzXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gam9iSWQgLSBKb2IgaWRlbnRpZmllclxyXG4gICAgICovXHJcbiAgICBhc3luYyBjbGVhbnVwSm9iKGpvYklkKSB7XHJcbiAgICAgICAgY29uc3Qgam9iID0gdGhpcy5hY3RpdmVKb2JzLmdldChqb2JJZCk7XHJcbiAgICAgICAgaWYgKGpvYikge1xyXG4gICAgICAgICAgICBhd2FpdCBmcy5yZW1vdmUoam9iLnRlbXBEaXIpO1xyXG4gICAgICAgICAgICB0aGlzLmFjdGl2ZUpvYnMuZGVsZXRlKGpvYklkKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbi8vIENyZWF0ZSBhbmQgZXhwb3J0IHRoZSBzaW5nbGV0b24gaW5zdGFuY2VcclxuY29uc3QgdHJhbnNjcmliZXJTZXJ2aWNlSW5zdGFuY2UgPSBuZXcgVHJhbnNjcmliZXJTZXJ2aWNlKCk7XHJcbm1vZHVsZS5leHBvcnRzID0gdHJhbnNjcmliZXJTZXJ2aWNlSW5zdGFuY2U7XHJcbiJdLCJtYXBwaW5ncyI6Ijs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxNQUFNQSxJQUFJLEdBQUdDLE9BQU8sQ0FBQyxNQUFN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