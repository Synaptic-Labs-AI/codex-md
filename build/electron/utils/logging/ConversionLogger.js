"use strict";

/**
 * ConversionLogger.js
 *
 * Provides standardized logging methods for conversion processes, integrating
 * with the ConversionStatus module to ensure consistent status tracking and
 * reporting throughout the conversion pipeline.
 *
 * This utility implements a class-based logger with methods for different log
 * levels and specialized methods for tracking conversion pipeline phases.
 *
 * Implements tiered buffer sanitization through LogSanitizer:
 * - Small buffers (<1MB): Include truncated preview
 * - Medium buffers (1-50MB): Include metadata only
 * - Large buffers (>50MB): Basic metadata only
 *
 * Related Files:
 * - src/electron/utils/logging/LogSanitizer.js: Handles buffer sanitization
 * - src/electron/utils/conversion/ConversionStatus.js: Provides status constants and utilities
 * - src/electron/services/conversion/multimedia/VideoConverter.js: Uses logger for conversion tracking
 * - src/electron/services/conversion/multimedia/AudioConverter.js: Uses logger for conversion tracking
 */

const ConversionStatus = require('../../utils/conversion/ConversionStatus');
const {
  sanitizeForLogging,
  createSanitizer,
  DEFAULT_CONFIG
} = require('./LogSanitizer');

// Configuration for conversion option sanitization
const CONVERSION_SANITIZE_CONFIG = {
  ...DEFAULT_CONFIG,
  maxLength: 50,
  // Limit array lengths for conversion options
  previewLength: 32,
  // Smaller preview for buffer contents
  truncateBuffers: true // Always truncate buffer contents
};

// Create a sanitizer instance with conversion-specific config
const sanitizeConversionOptions = createSanitizer(CONVERSION_SANITIZE_CONFIG);

/**
 * Class representing a conversion process logger
 * Provides standardized logging methods with consistent formatting
 */
class ConversionLogger {
  /**
   * Create a new ConversionLogger instance
   * @param {string} component - Component name (e.g., 'VideoConverter', 'AudioConverter')
   */
  constructor(component) {
    this.component = component;
    this.context = {};
    this.startTime = null;
  }

  /**
   * Set context information for subsequent log messages
   * @param {Object} context - Context information (e.g., conversionId, fileType)
   * @returns {ConversionLogger} - Returns this instance for method chaining
   */
  setContext(context) {
    this.context = {
      ...this.context,
      ...context
    };
    return this;
  }

  /**
   * Clear all context information
   * @returns {ConversionLogger} - Returns this instance for method chaining
   */
  clearContext() {
    this.context = {};
    return this;
  }

  /**
   * Format a log message with component, phase, and file type prefixes
   * @param {string} message - The message to format
   * @param {Object} context - Additional context for this specific message
   * @returns {string} - Formatted message with prefixes
   * @private
   */
  _formatMessage(message, context = {}) {
    const combinedContext = {
      ...this.context,
      ...context
    };
    const phase = combinedContext.phase ? `:${combinedContext.phase}` : '';
    const fileType = combinedContext.fileType ? `[${combinedContext.fileType}]` : '';
    return `[${this.component}${phase}]${fileType} ${message}`;
  }

  /**
   * Format timing information in a human-readable way
   * @param {number} timing - Timing in milliseconds
   * @returns {string} - Formatted timing string
   * @private
   */
  _formatTiming(timing) {
    if (timing < 1000) {
      return `${timing}ms`;
    } else if (timing < 60000) {
      return `${(timing / 1000).toFixed(2)}s`;
    } else {
      const minutes = Math.floor(timing / 60000);
      const seconds = (timing % 60000 / 1000).toFixed(1);
      return `${minutes}m ${seconds}s`;
    }
  }

  /**
   * Calculate elapsed time since conversion start or provided start time
   * @param {number} [startTimeOverride] - Optional start time to calculate from
   * @returns {number} - Elapsed time in milliseconds
   * @private
   */
  _getElapsedTime(startTimeOverride) {
    const start = startTimeOverride || this.startTime;
    if (!start) return 0;
    return Date.now() - start;
  }

  /**
   * Log a message with specified level
   * @param {string} message - Message to log
   * @param {string} [level='INFO'] - Log level (DEBUG, INFO, WARN, ERROR)
   * @param {Object} [context] - Additional context for this message
   */
  log(message, level = 'INFO', context = {}) {
    const formattedMessage = this._formatMessage(message, context);
    switch (level) {
      case 'DEBUG':
        console.debug(formattedMessage);
        break;
      case 'INFO':
        console.info(formattedMessage);
        break;
      case 'WARN':
        console.warn(formattedMessage);
        break;
      case 'ERROR':
        console.error(formattedMessage);
        break;
      default:
        console.info(formattedMessage);
    }
  }

  /**
   * Log a debug message
   * @param {string} message - Message to log
   * @param {Object} [context] - Additional context for this message
   */
  debug(message, context = {}) {
    this.log(message, 'DEBUG', context);
  }

  /**
   * Log an info message
   * @param {string} message - Message to log
   * @param {Object} [context] - Additional context for this message
   */
  info(message, context = {}) {
    this.log(message, 'INFO', context);
  }

  /**
   * Log a warning message
   * @param {string} message - Message to log
   * @param {Object} [context] - Additional context for this message
   */
  warn(message, context = {}) {
    this.log(message, 'WARN', context);
  }

  /**
   * Log an error message
   * @param {string} message - Message to log
   * @param {Object} [context] - Additional context for this message
   */
  error(message, context = {}) {
    this.log(message, 'ERROR', context);
  }

  /**
   * Log a success message
   * @param {string} message - Message to log
   * @param {Object} [context] - Additional context for this message
   */
  success(message, context = {}) {
    // Using console.info for success as console doesn't have a native success level
    this.log(`✅ ${message}`, 'INFO', context);
  }

  /**
   * Log a phase transition in the conversion pipeline
   * @param {string} fromStatus - Previous status from ConversionStatus.STATUS
   * @param {string} toStatus - New status from ConversionStatus.STATUS
   * @param {number} [timing] - Optional timing information in milliseconds
   */
  logPhaseTransition(fromStatus, toStatus, timing) {
    const fromDesc = ConversionStatus.getStatusDescription(fromStatus);
    const toDesc = ConversionStatus.getStatusDescription(toStatus);
    const toIcon = ConversionStatus.getStatusIcon(toStatus);
    let message = `Phase transition: ${fromDesc} → ${toIcon} ${toDesc}`;
    if (timing) {
      message += ` (took ${this._formatTiming(timing)})`;
    } else if (this.startTime) {
      const elapsed = this._getElapsedTime();
      message += ` (elapsed: ${this._formatTiming(elapsed)})`;
    }
    this.log(message, 'INFO', {
      phase: toStatus
    });
  }

  /**
   * Log the start of a conversion process
   * @param {string} fileType - Type of file being converted (e.g., 'mp4', 'pdf')
   * @param {Object} [options] - Conversion options
   */
  logConversionStart(fileType, options = {}) {
    this.startTime = Date.now();
    this.setContext({
      fileType,
      phase: ConversionStatus.STATUS.STARTING
    });
    const icon = ConversionStatus.getStatusIcon(ConversionStatus.STATUS.STARTING);
    let message = `${icon} Starting conversion`;
    if (options && Object.keys(options).length > 0) {
      try {
        // Log raw options structure for debugging
        this.debug(`Raw options type: ${typeof options}, keys: ${Object.keys(options)}`);

        // Use conversion-specific sanitizer for better buffer handling
        const sanitizedOptions = sanitizeConversionOptions(options);

        // Log sanitized structure before stringifying
        this.debug(`Sanitized options structure: ${Object.keys(sanitizedOptions)}`);

        // Try to stringify with fallback for large objects
        try {
          message += ` with options: ${JSON.stringify(sanitizedOptions)}`;
        } catch (jsonErr) {
          // If stringification fails, provide basic option info
          this.warn(`Could not stringify full options: ${jsonErr.message}`);
          message += ` with options: {keys: [${Object.keys(sanitizedOptions).join(', ')}]}`;
        }
      } catch (err) {
        // Log error but continue conversion process
        this.error(`Failed to process options: ${err.message}`, {
          error: err
        });
        this.debug(`Options processing error: ${err.stack}`);

        // Include basic options info in message
        message += ` with options: {type: ${typeof options}}`;
      }
    }
    this.log(message, 'INFO');
  }

  /**
   * Log the successful completion of a conversion
   * @param {string} fileType - Type of file that was converted
   * @param {number} [timing] - Optional explicit timing in milliseconds
   */
  logConversionComplete(fileType, timing) {
    const elapsed = timing || this._getElapsedTime();
    const formattedTime = this._formatTiming(elapsed);
    this.setContext({
      fileType,
      phase: ConversionStatus.STATUS.COMPLETED
    });
    const icon = ConversionStatus.getStatusIcon(ConversionStatus.STATUS.COMPLETED);
    this.success(`${icon} Conversion completed successfully in ${formattedTime}`);

    // Reset start time after completion
    this.startTime = null;
  }

  /**
   * Log a conversion error
   * @param {string} fileType - Type of file that was being converted
   * @param {Error|string} error - Error object or message
   */
  logConversionError(fileType, error) {
    this.setContext({
      fileType,
      phase: ConversionStatus.STATUS.ERROR
    });
    const icon = ConversionStatus.getStatusIcon(ConversionStatus.STATUS.ERROR);
    const errorMessage = error instanceof Error ? error.message : error;
    this.error(`${icon} Conversion failed: ${errorMessage}`);
    if (error instanceof Error && error.stack) {
      this.debug(`Error stack: ${error.stack}`);
    }

    // Reset start time after error
    this.startTime = null;
  }
}

// Singleton instance map to ensure consistent logger instances per component
const loggers = new Map();

/**
 * Get a ConversionLogger instance for a specific component
 * @param {string} component - Component name
 * @returns {ConversionLogger} - Logger instance for the component
 */
function getLogger(component) {
  if (!loggers.has(component)) {
    loggers.set(component, new ConversionLogger(component));
  }
  return loggers.get(component);
}

/**
 * Reset all loggers (mainly for testing purposes)
 */
function resetLoggers() {
  loggers.clear();
}
module.exports = {
  ConversionLogger,
  getLogger,
  resetLoggers
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJDb252ZXJzaW9uU3RhdHVzIiwicmVxdWlyZSIsInNhbml0aXplRm9yTG9nZ2luZyIsImNyZWF0ZVNhbml0aXplciIsIkRFRkFVTFRfQ09ORklHIiwiQ09OVkVSU0lPTl9TQU5JVElaRV9DT05GSUciLCJtYXhMZW5ndGgiLCJwcmV2aWV3TGVuZ3RoIiwidHJ1bmNhdGVCdWZmZXJzIiwic2FuaXRpemVDb252ZXJzaW9uT3B0aW9ucyIsIkNvbnZlcnNpb25Mb2dnZXIiLCJjb25zdHJ1Y3RvciIsImNvbXBvbmVudCIsImNvbnRleHQiLCJzdGFydFRpbWUiLCJzZXRDb250ZXh0IiwiY2xlYXJDb250ZXh0IiwiX2Zvcm1hdE1lc3NhZ2UiLCJtZXNzYWdlIiwiY29tYmluZWRDb250ZXh0IiwicGhhc2UiLCJmaWxlVHlwZSIsIl9mb3JtYXRUaW1pbmciLCJ0aW1pbmciLCJ0b0ZpeGVkIiwibWludXRlcyIsIk1hdGgiLCJmbG9vciIsInNlY29uZHMiLCJfZ2V0RWxhcHNlZFRpbWUiLCJzdGFydFRpbWVPdmVycmlkZSIsInN0YXJ0IiwiRGF0ZSIsIm5vdyIsImxvZyIsImxldmVsIiwiZm9ybWF0dGVkTWVzc2FnZSIsImNvbnNvbGUiLCJkZWJ1ZyIsImluZm8iLCJ3YXJuIiwiZXJyb3IiLCJzdWNjZXNzIiwibG9nUGhhc2VUcmFuc2l0aW9uIiwiZnJvbVN0YXR1cyIsInRvU3RhdHVzIiwiZnJvbURlc2MiLCJnZXRTdGF0dXNEZXNjcmlwdGlvbiIsInRvRGVzYyIsInRvSWNvbiIsImdldFN0YXR1c0ljb24iLCJlbGFwc2VkIiwibG9nQ29udmVyc2lvblN0YXJ0Iiwib3B0aW9ucyIsIlNUQVRVUyIsIlNUQVJUSU5HIiwiaWNvbiIsIk9iamVjdCIsImtleXMiLCJsZW5ndGgiLCJzYW5pdGl6ZWRPcHRpb25zIiwiSlNPTiIsInN0cmluZ2lmeSIsImpzb25FcnIiLCJqb2luIiwiZXJyIiwic3RhY2siLCJsb2dDb252ZXJzaW9uQ29tcGxldGUiLCJmb3JtYXR0ZWRUaW1lIiwiQ09NUExFVEVEIiwibG9nQ29udmVyc2lvbkVycm9yIiwiRVJST1IiLCJlcnJvck1lc3NhZ2UiLCJFcnJvciIsImxvZ2dlcnMiLCJNYXAiLCJnZXRMb2dnZXIiLCJoYXMiLCJzZXQiLCJnZXQiLCJyZXNldExvZ2dlcnMiLCJjbGVhciIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9zcmMvZWxlY3Ryb24vdXRpbHMvbG9nZ2luZy9Db252ZXJzaW9uTG9nZ2VyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29udmVyc2lvbkxvZ2dlci5qc1xuICpcbiAqIFByb3ZpZGVzIHN0YW5kYXJkaXplZCBsb2dnaW5nIG1ldGhvZHMgZm9yIGNvbnZlcnNpb24gcHJvY2Vzc2VzLCBpbnRlZ3JhdGluZ1xuICogd2l0aCB0aGUgQ29udmVyc2lvblN0YXR1cyBtb2R1bGUgdG8gZW5zdXJlIGNvbnNpc3RlbnQgc3RhdHVzIHRyYWNraW5nIGFuZFxuICogcmVwb3J0aW5nIHRocm91Z2hvdXQgdGhlIGNvbnZlcnNpb24gcGlwZWxpbmUuXG4gKlxuICogVGhpcyB1dGlsaXR5IGltcGxlbWVudHMgYSBjbGFzcy1iYXNlZCBsb2dnZXIgd2l0aCBtZXRob2RzIGZvciBkaWZmZXJlbnQgbG9nXG4gKiBsZXZlbHMgYW5kIHNwZWNpYWxpemVkIG1ldGhvZHMgZm9yIHRyYWNraW5nIGNvbnZlcnNpb24gcGlwZWxpbmUgcGhhc2VzLlxuICpcbiAqIEltcGxlbWVudHMgdGllcmVkIGJ1ZmZlciBzYW5pdGl6YXRpb24gdGhyb3VnaCBMb2dTYW5pdGl6ZXI6XG4gKiAtIFNtYWxsIGJ1ZmZlcnMgKDwxTUIpOiBJbmNsdWRlIHRydW5jYXRlZCBwcmV2aWV3XG4gKiAtIE1lZGl1bSBidWZmZXJzICgxLTUwTUIpOiBJbmNsdWRlIG1ldGFkYXRhIG9ubHlcbiAqIC0gTGFyZ2UgYnVmZmVycyAoPjUwTUIpOiBCYXNpYyBtZXRhZGF0YSBvbmx5XG4gKlxuICogUmVsYXRlZCBGaWxlczpcbiAqIC0gc3JjL2VsZWN0cm9uL3V0aWxzL2xvZ2dpbmcvTG9nU2FuaXRpemVyLmpzOiBIYW5kbGVzIGJ1ZmZlciBzYW5pdGl6YXRpb25cbiAqIC0gc3JjL2VsZWN0cm9uL3V0aWxzL2NvbnZlcnNpb24vQ29udmVyc2lvblN0YXR1cy5qczogUHJvdmlkZXMgc3RhdHVzIGNvbnN0YW50cyBhbmQgdXRpbGl0aWVzXG4gKiAtIHNyYy9lbGVjdHJvbi9zZXJ2aWNlcy9jb252ZXJzaW9uL211bHRpbWVkaWEvVmlkZW9Db252ZXJ0ZXIuanM6IFVzZXMgbG9nZ2VyIGZvciBjb252ZXJzaW9uIHRyYWNraW5nXG4gKiAtIHNyYy9lbGVjdHJvbi9zZXJ2aWNlcy9jb252ZXJzaW9uL211bHRpbWVkaWEvQXVkaW9Db252ZXJ0ZXIuanM6IFVzZXMgbG9nZ2VyIGZvciBjb252ZXJzaW9uIHRyYWNraW5nXG4gKi9cblxuY29uc3QgQ29udmVyc2lvblN0YXR1cyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2NvbnZlcnNpb24vQ29udmVyc2lvblN0YXR1cycpO1xuY29uc3QgeyBzYW5pdGl6ZUZvckxvZ2dpbmcsIGNyZWF0ZVNhbml0aXplciwgREVGQVVMVF9DT05GSUcgfSA9IHJlcXVpcmUoJy4vTG9nU2FuaXRpemVyJyk7XG5cbi8vIENvbmZpZ3VyYXRpb24gZm9yIGNvbnZlcnNpb24gb3B0aW9uIHNhbml0aXphdGlvblxuY29uc3QgQ09OVkVSU0lPTl9TQU5JVElaRV9DT05GSUcgPSB7XG4gIC4uLkRFRkFVTFRfQ09ORklHLFxuICBtYXhMZW5ndGg6IDUwLCAvLyBMaW1pdCBhcnJheSBsZW5ndGhzIGZvciBjb252ZXJzaW9uIG9wdGlvbnNcbiAgcHJldmlld0xlbmd0aDogMzIsIC8vIFNtYWxsZXIgcHJldmlldyBmb3IgYnVmZmVyIGNvbnRlbnRzXG4gIHRydW5jYXRlQnVmZmVyczogdHJ1ZSAvLyBBbHdheXMgdHJ1bmNhdGUgYnVmZmVyIGNvbnRlbnRzXG59O1xuXG4vLyBDcmVhdGUgYSBzYW5pdGl6ZXIgaW5zdGFuY2Ugd2l0aCBjb252ZXJzaW9uLXNwZWNpZmljIGNvbmZpZ1xuY29uc3Qgc2FuaXRpemVDb252ZXJzaW9uT3B0aW9ucyA9IGNyZWF0ZVNhbml0aXplcihDT05WRVJTSU9OX1NBTklUSVpFX0NPTkZJRyk7XG5cbi8qKlxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGEgY29udmVyc2lvbiBwcm9jZXNzIGxvZ2dlclxuICogUHJvdmlkZXMgc3RhbmRhcmRpemVkIGxvZ2dpbmcgbWV0aG9kcyB3aXRoIGNvbnNpc3RlbnQgZm9ybWF0dGluZ1xuICovXG5jbGFzcyBDb252ZXJzaW9uTG9nZ2VyIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBDb252ZXJzaW9uTG9nZ2VyIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjb21wb25lbnQgLSBDb21wb25lbnQgbmFtZSAoZS5nLiwgJ1ZpZGVvQ29udmVydGVyJywgJ0F1ZGlvQ29udmVydGVyJylcbiAgICovXG4gIGNvbnN0cnVjdG9yKGNvbXBvbmVudCkge1xuICAgIHRoaXMuY29tcG9uZW50ID0gY29tcG9uZW50O1xuICAgIHRoaXMuY29udGV4dCA9IHt9O1xuICAgIHRoaXMuc3RhcnRUaW1lID0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgY29udGV4dCBpbmZvcm1hdGlvbiBmb3Igc3Vic2VxdWVudCBsb2cgbWVzc2FnZXNcbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHQgLSBDb250ZXh0IGluZm9ybWF0aW9uIChlLmcuLCBjb252ZXJzaW9uSWQsIGZpbGVUeXBlKVxuICAgKiBAcmV0dXJucyB7Q29udmVyc2lvbkxvZ2dlcn0gLSBSZXR1cm5zIHRoaXMgaW5zdGFuY2UgZm9yIG1ldGhvZCBjaGFpbmluZ1xuICAgKi9cbiAgc2V0Q29udGV4dChjb250ZXh0KSB7XG4gICAgdGhpcy5jb250ZXh0ID0geyAuLi50aGlzLmNvbnRleHQsIC4uLmNvbnRleHQgfTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhciBhbGwgY29udGV4dCBpbmZvcm1hdGlvblxuICAgKiBAcmV0dXJucyB7Q29udmVyc2lvbkxvZ2dlcn0gLSBSZXR1cm5zIHRoaXMgaW5zdGFuY2UgZm9yIG1ldGhvZCBjaGFpbmluZ1xuICAgKi9cbiAgY2xlYXJDb250ZXh0KCkge1xuICAgIHRoaXMuY29udGV4dCA9IHt9O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEZvcm1hdCBhIGxvZyBtZXNzYWdlIHdpdGggY29tcG9uZW50LCBwaGFzZSwgYW5kIGZpbGUgdHlwZSBwcmVmaXhlc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZSAtIFRoZSBtZXNzYWdlIHRvIGZvcm1hdFxuICAgKiBAcGFyYW0ge09iamVjdH0gY29udGV4dCAtIEFkZGl0aW9uYWwgY29udGV4dCBmb3IgdGhpcyBzcGVjaWZpYyBtZXNzYWdlXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IC0gRm9ybWF0dGVkIG1lc3NhZ2Ugd2l0aCBwcmVmaXhlc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2Zvcm1hdE1lc3NhZ2UobWVzc2FnZSwgY29udGV4dCA9IHt9KSB7XG4gICAgY29uc3QgY29tYmluZWRDb250ZXh0ID0geyAuLi50aGlzLmNvbnRleHQsIC4uLmNvbnRleHQgfTtcbiAgICBjb25zdCBwaGFzZSA9IGNvbWJpbmVkQ29udGV4dC5waGFzZSA/IGA6JHtjb21iaW5lZENvbnRleHQucGhhc2V9YCA6ICcnO1xuICAgIGNvbnN0IGZpbGVUeXBlID0gY29tYmluZWRDb250ZXh0LmZpbGVUeXBlID8gYFske2NvbWJpbmVkQ29udGV4dC5maWxlVHlwZX1dYCA6ICcnO1xuICAgIFxuICAgIHJldHVybiBgWyR7dGhpcy5jb21wb25lbnR9JHtwaGFzZX1dJHtmaWxlVHlwZX0gJHttZXNzYWdlfWA7XG4gIH1cblxuICAvKipcbiAgICogRm9ybWF0IHRpbWluZyBpbmZvcm1hdGlvbiBpbiBhIGh1bWFuLXJlYWRhYmxlIHdheVxuICAgKiBAcGFyYW0ge251bWJlcn0gdGltaW5nIC0gVGltaW5nIGluIG1pbGxpc2Vjb25kc1xuICAgKiBAcmV0dXJucyB7c3RyaW5nfSAtIEZvcm1hdHRlZCB0aW1pbmcgc3RyaW5nXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZm9ybWF0VGltaW5nKHRpbWluZykge1xuICAgIGlmICh0aW1pbmcgPCAxMDAwKSB7XG4gICAgICByZXR1cm4gYCR7dGltaW5nfW1zYDtcbiAgICB9IGVsc2UgaWYgKHRpbWluZyA8IDYwMDAwKSB7XG4gICAgICByZXR1cm4gYCR7KHRpbWluZyAvIDEwMDApLnRvRml4ZWQoMil9c2A7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG1pbnV0ZXMgPSBNYXRoLmZsb29yKHRpbWluZyAvIDYwMDAwKTtcbiAgICAgIGNvbnN0IHNlY29uZHMgPSAoKHRpbWluZyAlIDYwMDAwKSAvIDEwMDApLnRvRml4ZWQoMSk7XG4gICAgICByZXR1cm4gYCR7bWludXRlc31tICR7c2Vjb25kc31zYDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYXRlIGVsYXBzZWQgdGltZSBzaW5jZSBjb252ZXJzaW9uIHN0YXJ0IG9yIHByb3ZpZGVkIHN0YXJ0IHRpbWVcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydFRpbWVPdmVycmlkZV0gLSBPcHRpb25hbCBzdGFydCB0aW1lIHRvIGNhbGN1bGF0ZSBmcm9tXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IC0gRWxhcHNlZCB0aW1lIGluIG1pbGxpc2Vjb25kc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2dldEVsYXBzZWRUaW1lKHN0YXJ0VGltZU92ZXJyaWRlKSB7XG4gICAgY29uc3Qgc3RhcnQgPSBzdGFydFRpbWVPdmVycmlkZSB8fCB0aGlzLnN0YXJ0VGltZTtcbiAgICBpZiAoIXN0YXJ0KSByZXR1cm4gMDtcbiAgICBcbiAgICByZXR1cm4gRGF0ZS5ub3coKSAtIHN0YXJ0O1xuICB9XG5cbiAgLyoqXG4gICAqIExvZyBhIG1lc3NhZ2Ugd2l0aCBzcGVjaWZpZWQgbGV2ZWxcbiAgICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgLSBNZXNzYWdlIHRvIGxvZ1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW2xldmVsPSdJTkZPJ10gLSBMb2cgbGV2ZWwgKERFQlVHLCBJTkZPLCBXQVJOLCBFUlJPUilcbiAgICogQHBhcmFtIHtPYmplY3R9IFtjb250ZXh0XSAtIEFkZGl0aW9uYWwgY29udGV4dCBmb3IgdGhpcyBtZXNzYWdlXG4gICAqL1xuICBsb2cobWVzc2FnZSwgbGV2ZWwgPSAnSU5GTycsIGNvbnRleHQgPSB7fSkge1xuICAgIGNvbnN0IGZvcm1hdHRlZE1lc3NhZ2UgPSB0aGlzLl9mb3JtYXRNZXNzYWdlKG1lc3NhZ2UsIGNvbnRleHQpO1xuICAgIFxuICAgIHN3aXRjaChsZXZlbCkge1xuICAgICAgY2FzZSAnREVCVUcnOlxuICAgICAgICBjb25zb2xlLmRlYnVnKGZvcm1hdHRlZE1lc3NhZ2UpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0lORk8nOlxuICAgICAgICBjb25zb2xlLmluZm8oZm9ybWF0dGVkTWVzc2FnZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnV0FSTic6XG4gICAgICAgIGNvbnNvbGUud2Fybihmb3JtYXR0ZWRNZXNzYWdlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdFUlJPUic6XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZm9ybWF0dGVkTWVzc2FnZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgY29uc29sZS5pbmZvKGZvcm1hdHRlZE1lc3NhZ2UpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBMb2cgYSBkZWJ1ZyBtZXNzYWdlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIC0gTWVzc2FnZSB0byBsb2dcbiAgICogQHBhcmFtIHtPYmplY3R9IFtjb250ZXh0XSAtIEFkZGl0aW9uYWwgY29udGV4dCBmb3IgdGhpcyBtZXNzYWdlXG4gICAqL1xuICBkZWJ1ZyhtZXNzYWdlLCBjb250ZXh0ID0ge30pIHtcbiAgICB0aGlzLmxvZyhtZXNzYWdlLCAnREVCVUcnLCBjb250ZXh0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2cgYW4gaW5mbyBtZXNzYWdlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIC0gTWVzc2FnZSB0byBsb2dcbiAgICogQHBhcmFtIHtPYmplY3R9IFtjb250ZXh0XSAtIEFkZGl0aW9uYWwgY29udGV4dCBmb3IgdGhpcyBtZXNzYWdlXG4gICAqL1xuICBpbmZvKG1lc3NhZ2UsIGNvbnRleHQgPSB7fSkge1xuICAgIHRoaXMubG9nKG1lc3NhZ2UsICdJTkZPJywgY29udGV4dCk7XG4gIH1cblxuICAvKipcbiAgICogTG9nIGEgd2FybmluZyBtZXNzYWdlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIC0gTWVzc2FnZSB0byBsb2dcbiAgICogQHBhcmFtIHtPYmplY3R9IFtjb250ZXh0XSAtIEFkZGl0aW9uYWwgY29udGV4dCBmb3IgdGhpcyBtZXNzYWdlXG4gICAqL1xuICB3YXJuKG1lc3NhZ2UsIGNvbnRleHQgPSB7fSkge1xuICAgIHRoaXMubG9nKG1lc3NhZ2UsICdXQVJOJywgY29udGV4dCk7XG4gIH1cblxuICAvKipcbiAgICogTG9nIGFuIGVycm9yIG1lc3NhZ2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgLSBNZXNzYWdlIHRvIGxvZ1xuICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbnRleHRdIC0gQWRkaXRpb25hbCBjb250ZXh0IGZvciB0aGlzIG1lc3NhZ2VcbiAgICovXG4gIGVycm9yKG1lc3NhZ2UsIGNvbnRleHQgPSB7fSkge1xuICAgIHRoaXMubG9nKG1lc3NhZ2UsICdFUlJPUicsIGNvbnRleHQpO1xuICB9XG5cbiAgLyoqXG4gICAqIExvZyBhIHN1Y2Nlc3MgbWVzc2FnZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZSAtIE1lc3NhZ2UgdG8gbG9nXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbY29udGV4dF0gLSBBZGRpdGlvbmFsIGNvbnRleHQgZm9yIHRoaXMgbWVzc2FnZVxuICAgKi9cbiAgc3VjY2VzcyhtZXNzYWdlLCBjb250ZXh0ID0ge30pIHtcbiAgICAvLyBVc2luZyBjb25zb2xlLmluZm8gZm9yIHN1Y2Nlc3MgYXMgY29uc29sZSBkb2Vzbid0IGhhdmUgYSBuYXRpdmUgc3VjY2VzcyBsZXZlbFxuICAgIHRoaXMubG9nKGDinIUgJHttZXNzYWdlfWAsICdJTkZPJywgY29udGV4dCk7XG4gIH1cblxuICAvKipcbiAgICogTG9nIGEgcGhhc2UgdHJhbnNpdGlvbiBpbiB0aGUgY29udmVyc2lvbiBwaXBlbGluZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gZnJvbVN0YXR1cyAtIFByZXZpb3VzIHN0YXR1cyBmcm9tIENvbnZlcnNpb25TdGF0dXMuU1RBVFVTXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0b1N0YXR1cyAtIE5ldyBzdGF0dXMgZnJvbSBDb252ZXJzaW9uU3RhdHVzLlNUQVRVU1xuICAgKiBAcGFyYW0ge251bWJlcn0gW3RpbWluZ10gLSBPcHRpb25hbCB0aW1pbmcgaW5mb3JtYXRpb24gaW4gbWlsbGlzZWNvbmRzXG4gICAqL1xuICBsb2dQaGFzZVRyYW5zaXRpb24oZnJvbVN0YXR1cywgdG9TdGF0dXMsIHRpbWluZykge1xuICAgIGNvbnN0IGZyb21EZXNjID0gQ29udmVyc2lvblN0YXR1cy5nZXRTdGF0dXNEZXNjcmlwdGlvbihmcm9tU3RhdHVzKTtcbiAgICBjb25zdCB0b0Rlc2MgPSBDb252ZXJzaW9uU3RhdHVzLmdldFN0YXR1c0Rlc2NyaXB0aW9uKHRvU3RhdHVzKTtcbiAgICBjb25zdCB0b0ljb24gPSBDb252ZXJzaW9uU3RhdHVzLmdldFN0YXR1c0ljb24odG9TdGF0dXMpO1xuICAgIFxuICAgIGxldCBtZXNzYWdlID0gYFBoYXNlIHRyYW5zaXRpb246ICR7ZnJvbURlc2N9IOKGkiAke3RvSWNvbn0gJHt0b0Rlc2N9YDtcbiAgICBcbiAgICBpZiAodGltaW5nKSB7XG4gICAgICBtZXNzYWdlICs9IGAgKHRvb2sgJHt0aGlzLl9mb3JtYXRUaW1pbmcodGltaW5nKX0pYDtcbiAgICB9IGVsc2UgaWYgKHRoaXMuc3RhcnRUaW1lKSB7XG4gICAgICBjb25zdCBlbGFwc2VkID0gdGhpcy5fZ2V0RWxhcHNlZFRpbWUoKTtcbiAgICAgIG1lc3NhZ2UgKz0gYCAoZWxhcHNlZDogJHt0aGlzLl9mb3JtYXRUaW1pbmcoZWxhcHNlZCl9KWA7XG4gICAgfVxuICAgIFxuICAgIHRoaXMubG9nKG1lc3NhZ2UsICdJTkZPJywgeyBwaGFzZTogdG9TdGF0dXMgfSk7XG4gIH1cblxuICAvKipcbiAgICogTG9nIHRoZSBzdGFydCBvZiBhIGNvbnZlcnNpb24gcHJvY2Vzc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gZmlsZVR5cGUgLSBUeXBlIG9mIGZpbGUgYmVpbmcgY29udmVydGVkIChlLmcuLCAnbXA0JywgJ3BkZicpXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBDb252ZXJzaW9uIG9wdGlvbnNcbiAgICovXG4gIGxvZ0NvbnZlcnNpb25TdGFydChmaWxlVHlwZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy5zdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgIHRoaXMuc2V0Q29udGV4dCh7IGZpbGVUeXBlLCBwaGFzZTogQ29udmVyc2lvblN0YXR1cy5TVEFUVVMuU1RBUlRJTkcgfSk7XG4gICAgXG4gICAgY29uc3QgaWNvbiA9IENvbnZlcnNpb25TdGF0dXMuZ2V0U3RhdHVzSWNvbihDb252ZXJzaW9uU3RhdHVzLlNUQVRVUy5TVEFSVElORyk7XG4gICAgbGV0IG1lc3NhZ2UgPSBgJHtpY29ufSBTdGFydGluZyBjb252ZXJzaW9uYDtcbiAgICBcbiAgICBpZiAob3B0aW9ucyAmJiBPYmplY3Qua2V5cyhvcHRpb25zKS5sZW5ndGggPiAwKSB7XG4gICAgICB0cnkge1xuICAgICAgICAvLyBMb2cgcmF3IG9wdGlvbnMgc3RydWN0dXJlIGZvciBkZWJ1Z2dpbmdcbiAgICAgICAgdGhpcy5kZWJ1ZyhgUmF3IG9wdGlvbnMgdHlwZTogJHt0eXBlb2Ygb3B0aW9uc30sIGtleXM6ICR7T2JqZWN0LmtleXMob3B0aW9ucyl9YCk7XG4gICAgICAgIFxuICAgICAgICAvLyBVc2UgY29udmVyc2lvbi1zcGVjaWZpYyBzYW5pdGl6ZXIgZm9yIGJldHRlciBidWZmZXIgaGFuZGxpbmdcbiAgICAgICAgY29uc3Qgc2FuaXRpemVkT3B0aW9ucyA9IHNhbml0aXplQ29udmVyc2lvbk9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIFxuICAgICAgICAvLyBMb2cgc2FuaXRpemVkIHN0cnVjdHVyZSBiZWZvcmUgc3RyaW5naWZ5aW5nXG4gICAgICAgIHRoaXMuZGVidWcoYFNhbml0aXplZCBvcHRpb25zIHN0cnVjdHVyZTogJHtPYmplY3Qua2V5cyhzYW5pdGl6ZWRPcHRpb25zKX1gKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFRyeSB0byBzdHJpbmdpZnkgd2l0aCBmYWxsYmFjayBmb3IgbGFyZ2Ugb2JqZWN0c1xuICAgICAgICB0cnkge1xuICAgICAgICAgIG1lc3NhZ2UgKz0gYCB3aXRoIG9wdGlvbnM6ICR7SlNPTi5zdHJpbmdpZnkoc2FuaXRpemVkT3B0aW9ucyl9YDtcbiAgICAgICAgfSBjYXRjaCAoanNvbkVycikge1xuICAgICAgICAgIC8vIElmIHN0cmluZ2lmaWNhdGlvbiBmYWlscywgcHJvdmlkZSBiYXNpYyBvcHRpb24gaW5mb1xuICAgICAgICAgIHRoaXMud2FybihgQ291bGQgbm90IHN0cmluZ2lmeSBmdWxsIG9wdGlvbnM6ICR7anNvbkVyci5tZXNzYWdlfWApO1xuICAgICAgICAgIG1lc3NhZ2UgKz0gYCB3aXRoIG9wdGlvbnM6IHtrZXlzOiBbJHtPYmplY3Qua2V5cyhzYW5pdGl6ZWRPcHRpb25zKS5qb2luKCcsICcpfV19YDtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIC8vIExvZyBlcnJvciBidXQgY29udGludWUgY29udmVyc2lvbiBwcm9jZXNzXG4gICAgICAgIHRoaXMuZXJyb3IoYEZhaWxlZCB0byBwcm9jZXNzIG9wdGlvbnM6ICR7ZXJyLm1lc3NhZ2V9YCwgeyBlcnJvcjogZXJyIH0pO1xuICAgICAgICB0aGlzLmRlYnVnKGBPcHRpb25zIHByb2Nlc3NpbmcgZXJyb3I6ICR7ZXJyLnN0YWNrfWApO1xuICAgICAgICBcbiAgICAgICAgLy8gSW5jbHVkZSBiYXNpYyBvcHRpb25zIGluZm8gaW4gbWVzc2FnZVxuICAgICAgICBtZXNzYWdlICs9IGAgd2l0aCBvcHRpb25zOiB7dHlwZTogJHt0eXBlb2Ygb3B0aW9uc319YDtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgdGhpcy5sb2cobWVzc2FnZSwgJ0lORk8nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2cgdGhlIHN1Y2Nlc3NmdWwgY29tcGxldGlvbiBvZiBhIGNvbnZlcnNpb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IGZpbGVUeXBlIC0gVHlwZSBvZiBmaWxlIHRoYXQgd2FzIGNvbnZlcnRlZFxuICAgKiBAcGFyYW0ge251bWJlcn0gW3RpbWluZ10gLSBPcHRpb25hbCBleHBsaWNpdCB0aW1pbmcgaW4gbWlsbGlzZWNvbmRzXG4gICAqL1xuICBsb2dDb252ZXJzaW9uQ29tcGxldGUoZmlsZVR5cGUsIHRpbWluZykge1xuICAgIGNvbnN0IGVsYXBzZWQgPSB0aW1pbmcgfHwgdGhpcy5fZ2V0RWxhcHNlZFRpbWUoKTtcbiAgICBjb25zdCBmb3JtYXR0ZWRUaW1lID0gdGhpcy5fZm9ybWF0VGltaW5nKGVsYXBzZWQpO1xuICAgIFxuICAgIHRoaXMuc2V0Q29udGV4dCh7IGZpbGVUeXBlLCBwaGFzZTogQ29udmVyc2lvblN0YXR1cy5TVEFUVVMuQ09NUExFVEVEIH0pO1xuICAgIFxuICAgIGNvbnN0IGljb24gPSBDb252ZXJzaW9uU3RhdHVzLmdldFN0YXR1c0ljb24oQ29udmVyc2lvblN0YXR1cy5TVEFUVVMuQ09NUExFVEVEKTtcbiAgICB0aGlzLnN1Y2Nlc3MoYCR7aWNvbn0gQ29udmVyc2lvbiBjb21wbGV0ZWQgc3VjY2Vzc2Z1bGx5IGluICR7Zm9ybWF0dGVkVGltZX1gKTtcbiAgICBcbiAgICAvLyBSZXNldCBzdGFydCB0aW1lIGFmdGVyIGNvbXBsZXRpb25cbiAgICB0aGlzLnN0YXJ0VGltZSA9IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogTG9nIGEgY29udmVyc2lvbiBlcnJvclxuICAgKiBAcGFyYW0ge3N0cmluZ30gZmlsZVR5cGUgLSBUeXBlIG9mIGZpbGUgdGhhdCB3YXMgYmVpbmcgY29udmVydGVkXG4gICAqIEBwYXJhbSB7RXJyb3J8c3RyaW5nfSBlcnJvciAtIEVycm9yIG9iamVjdCBvciBtZXNzYWdlXG4gICAqL1xuICBsb2dDb252ZXJzaW9uRXJyb3IoZmlsZVR5cGUsIGVycm9yKSB7XG4gICAgdGhpcy5zZXRDb250ZXh0KHsgZmlsZVR5cGUsIHBoYXNlOiBDb252ZXJzaW9uU3RhdHVzLlNUQVRVUy5FUlJPUiB9KTtcbiAgICBcbiAgICBjb25zdCBpY29uID0gQ29udmVyc2lvblN0YXR1cy5nZXRTdGF0dXNJY29uKENvbnZlcnNpb25TdGF0dXMuU1RBVFVTLkVSUk9SKTtcbiAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IGVycm9yO1xuICAgIFxuICAgIHRoaXMuZXJyb3IoYCR7aWNvbn0gQ29udmVyc2lvbiBmYWlsZWQ6ICR7ZXJyb3JNZXNzYWdlfWApO1xuICAgIFxuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmIGVycm9yLnN0YWNrKSB7XG4gICAgICB0aGlzLmRlYnVnKGBFcnJvciBzdGFjazogJHtlcnJvci5zdGFja31gKTtcbiAgICB9XG4gICAgXG4gICAgLy8gUmVzZXQgc3RhcnQgdGltZSBhZnRlciBlcnJvclxuICAgIHRoaXMuc3RhcnRUaW1lID0gbnVsbDtcbiAgfVxuXG59XG5cbi8vIFNpbmdsZXRvbiBpbnN0YW5jZSBtYXAgdG8gZW5zdXJlIGNvbnNpc3RlbnQgbG9nZ2VyIGluc3RhbmNlcyBwZXIgY29tcG9uZW50XG5jb25zdCBsb2dnZXJzID0gbmV3IE1hcCgpO1xuXG4vKipcbiAqIEdldCBhIENvbnZlcnNpb25Mb2dnZXIgaW5zdGFuY2UgZm9yIGEgc3BlY2lmaWMgY29tcG9uZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gY29tcG9uZW50IC0gQ29tcG9uZW50IG5hbWVcbiAqIEByZXR1cm5zIHtDb252ZXJzaW9uTG9nZ2VyfSAtIExvZ2dlciBpbnN0YW5jZSBmb3IgdGhlIGNvbXBvbmVudFxuICovXG5mdW5jdGlvbiBnZXRMb2dnZXIoY29tcG9uZW50KSB7XG4gIGlmICghbG9nZ2Vycy5oYXMoY29tcG9uZW50KSkge1xuICAgIGxvZ2dlcnMuc2V0KGNvbXBvbmVudCwgbmV3IENvbnZlcnNpb25Mb2dnZXIoY29tcG9uZW50KSk7XG4gIH1cbiAgcmV0dXJuIGxvZ2dlcnMuZ2V0KGNvbXBvbmVudCk7XG59XG5cbi8qKlxuICogUmVzZXQgYWxsIGxvZ2dlcnMgKG1haW5seSBmb3IgdGVzdGluZyBwdXJwb3NlcylcbiAqL1xuZnVuY3Rpb24gcmVzZXRMb2dnZXJzKCkge1xuICBsb2dnZXJzLmNsZWFyKCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBDb252ZXJzaW9uTG9nZ2VyLFxuICBnZXRMb2dnZXIsXG4gIHJlc2V0TG9nZ2Vyc1xufTsiXSwibWFwcGluZ3MiOiI7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE1BQU1BLGdCQUFnQixHQUFHQyxPQUFPLENBQUMseUNBQXlDLENBQUM7QUFDM0UsTUFBTTtFQUFFQyxrQkFBa0I7RUFBRUMsZUFBZTtFQUFFQztBQUFlLENBQUMsR0FBR0gsT0FBTyxDQUFDLGdCQUFnQixDQUFDOztBQUV6RjtBQUNBLE1BQU1JLDBCQUEwQixHQUFHO0VBQ2pDLEdBQUdELGNBQWM7RUFDakJFLFNBQVMs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