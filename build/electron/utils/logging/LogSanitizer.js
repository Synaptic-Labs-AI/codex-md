"use strict";

/**
 * LogSanitizer.js
 * 
 * Provides utilities for sanitizing objects before logging, handling common 
 * cases like Buffers, circular references, and deeply nested objects.
 * 
 * Implements a tiered buffer sanitization approach to prevent:
 * - V8 "Invalid string length" errors from large buffers (>512MB)
 * - Memory issues from excessive buffer data in logs
 * - Loss of critical debugging information
 * 
 * Buffer Size Tiers:
 * - Small (<1MB): Include truncated preview of buffer data
 * - Medium (1-50MB): Include only metadata (size, type, hash)
 * - Large (>50MB): Basic metadata only
 * 
 * Related Files:
 * - src/electron/utils/logging/ConversionLogger.js
 * - src/electron/converters/UnifiedConverterFactory.js
 * - src/electron/services/conversion/multimedia/VideoConverter.js
 */

const crypto = require('crypto');

// Buffer size thresholds in bytes
const BUFFER_THRESHOLDS = {
  SMALL: 1024 * 1024,
  // 1MB
  MEDIUM: 50 * 1024 * 1024 // 50MB
};

/**
 * Configuration object for sanitization options
 * @typedef {Object} SanitizeConfig
 * @property {number} maxDepth - Maximum depth for nested object traversal 
 * @property {number} maxLength - Maximum length for array/buffer preview
 * @property {boolean} truncateBuffers - Whether to truncate buffer contents
 * @property {number} previewLength - Maximum length of buffer data preview
 */

/** @type {SanitizeConfig} */
const DEFAULT_CONFIG = {
  maxDepth: 3,
  maxLength: 100,
  truncateBuffers: true,
  previewLength: 50 // Default preview length for small buffers
};

/**
 * Determines the appropriate sanitization strategy based on buffer size
 * @param {Buffer} buffer - The buffer to classify
 * @returns {'small'|'medium'|'large'} The size classification
 */
function classifyBufferSize(buffer) {
  const size = buffer.length;
  if (size < BUFFER_THRESHOLDS.SMALL) return 'small';
  if (size < BUFFER_THRESHOLDS.MEDIUM) return 'medium';
  return 'large';
}

/**
 * Extracts metadata from a buffer for logging
 * @param {Buffer} buffer - The buffer to extract metadata from
 * @returns {Object} Buffer metadata
 */
function extractBufferMetadata(buffer) {
  // Calculate a hash of the first 16KB to help identify content
  // without processing the entire buffer
  const hash = crypto.createHash('sha256').update(buffer.slice(0, 16384)).digest('hex').slice(0, 16); // First 16 chars of hash is sufficient

  return {
    size: buffer.length,
    sizeFormatted: formatSize(buffer.length),
    type: detectBufferType(buffer),
    hash
  };
}

/**
 * Formats a byte size into a human-readable string
 * @param {number} bytes - The size in bytes
 * @returns {string} Formatted size string
 */
function formatSize(bytes) {
  const units = ['B', 'KB', 'MB', 'GB'];
  let size = bytes;
  let unitIndex = 0;
  while (size >= 1024 && unitIndex < units.length - 1) {
    size /= 1024;
    unitIndex++;
  }
  return `${size.toFixed(1)}${units[unitIndex]}`;
}

/**
 * Attempts to detect the type of data in a buffer
 * @param {Buffer} buffer - The buffer to analyze
 * @returns {string} Detected type description
 */
function detectBufferType(buffer) {
  // Check file signatures/magic numbers
  if (buffer.length < 4) return 'unknown';
  const header = buffer.slice(0, 4).toString('hex');

  // Common file signatures
  if (header.startsWith('89504e47')) return 'image/png';
  if (header.startsWith('ffd8ff')) return 'image/jpeg';
  if (header.startsWith('47494638')) return 'image/gif';
  if (header.startsWith('52494646')) return 'video/webm';

  // Try to detect if it's UTF-8 text
  try {
    const sample = buffer.slice(0, 32).toString('utf8');
    if (/^[\x20-\x7F\n\r\t]*$/.test(sample)) return 'text/plain';
  } catch {}
  return 'application/octet-stream';
}

/**
 * Sanitizes an object for logging by handling special cases and preventing issues
 * @param {any} obj - The object to sanitize
 * @param {SanitizeConfig} [config] - Configuration options
 * @returns {any} - The sanitized object safe for logging
 */
function sanitizeForLogging(obj, config = DEFAULT_CONFIG) {
  // Use WeakSet to track object references and prevent circular recursion
  const seen = new WeakSet();

  /**
   * Internal recursive sanitization function with depth tracking
   * @param {any} value - Value to sanitize
   * @param {number} depth - Current recursion depth
   * @returns {any} - Sanitized value
   */
  function sanitizeValue(value, depth = 0) {
    // Handle null/undefined
    if (value == null) return value;

    // Handle Buffers using tiered approach
    if (Buffer.isBuffer(value)) {
      const sizeClass = classifyBufferSize(value);
      const metadata = extractBufferMetadata(value);

      // Apply tiered sanitization strategy
      switch (sizeClass) {
        case 'small':
          return {
            type: '[Buffer]',
            ...metadata,
            preview: value.slice(0, config.previewLength).toString('hex')
          };
        case 'medium':
          return {
            type: '[Buffer]',
            ...metadata
          };
        case 'large':
          return {
            type: '[Large Buffer]',
            size: metadata.size,
            sizeFormatted: metadata.sizeFormatted
          };
      }
    }

    // Handle primitive types
    if (typeof value !== 'object') {
      return value;
    }

    // Check for circular references
    if (seen.has(value)) {
      return '[Circular Reference]';
    }

    // Check depth limit
    if (depth >= config.maxDepth) {
      return '[Max Depth Reached]';
    }

    // Track this object to detect circular refs
    seen.add(value);

    // Handle arrays
    if (Array.isArray(value)) {
      const sanitizedArray = value.slice(0, config.maxLength).map(item => sanitizeValue(item, depth + 1));
      if (value.length > config.maxLength) {
        sanitizedArray.push(`...${value.length - config.maxLength} more items`);
      }
      return sanitizedArray;
    }

    // Handle special Node.js objects
    if (value._handle || value._readableState || value._writableState) {
      return '[Stream/Handle]';
    }

    // Handle regular objects
    const sanitized = {};
    for (const [key, val] of Object.entries(value)) {
      sanitized[key] = sanitizeValue(val, depth + 1);
    }
    return sanitized;
  }
  return sanitizeValue(obj);
}

/**
 * Creates a sanitizer with custom configuration
 * @param {SanitizeConfig} config - Custom configuration options
 * @returns {function(any): any} - Configured sanitizer function
 */
function createSanitizer(config) {
  const finalConfig = {
    ...DEFAULT_CONFIG,
    ...config
  };
  return obj => sanitizeForLogging(obj, finalConfig);
}
module.exports = {
  sanitizeForLogging,
  createSanitizer,
  DEFAULT_CONFIG,
  BUFFER_THRESHOLDS
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJjcnlwdG8iLCJyZXF1aXJlIiwiQlVGRkVSX1RIUkVTSE9MRFMiLCJTTUFMTCIsIk1FRElVTSIsIkRFRkFVTFRfQ09ORklHIiwibWF4RGVwdGgiLCJtYXhMZW5ndGgiLCJ0cnVuY2F0ZUJ1ZmZlcnMiLCJwcmV2aWV3TGVuZ3RoIiwiY2xhc3NpZnlCdWZmZXJTaXplIiwiYnVmZmVyIiwic2l6ZSIsImxlbmd0aCIsImV4dHJhY3RCdWZmZXJNZXRhZGF0YSIsImhhc2giLCJjcmVhdGVIYXNoIiwidXBkYXRlIiwic2xpY2UiLCJkaWdlc3QiLCJzaXplRm9ybWF0dGVkIiwiZm9ybWF0U2l6ZSIsInR5cGUiLCJkZXRlY3RCdWZmZXJUeXBlIiwiYnl0ZXMiLCJ1bml0cyIsInVuaXRJbmRleCIsInRvRml4ZWQiLCJoZWFkZXIiLCJ0b1N0cmluZyIsInN0YXJ0c1dpdGgiLCJzYW1wbGUiLCJ0ZXN0Iiwic2FuaXRpemVGb3JMb2dnaW5nIiwib2JqIiwiY29uZmlnIiwic2VlbiIsIldlYWtTZXQiLCJzYW5pdGl6ZVZhbHVlIiwidmFsdWUiLCJkZXB0aCIsIkJ1ZmZlciIsImlzQnVmZmVyIiwic2l6ZUNsYXNzIiwibWV0YWRhdGEiLCJwcmV2aWV3IiwiaGFzIiwiYWRkIiwiQXJyYXkiLCJpc0FycmF5Iiwic2FuaXRpemVkQXJyYXkiLCJtYXAiLCJpdGVtIiwicHVzaCIsIl9oYW5kbGUiLCJfcmVhZGFibGVTdGF0ZSIsIl93cml0YWJsZVN0YXRlIiwic2FuaXRpemVkIiwia2V5IiwidmFsIiwiT2JqZWN0IiwiZW50cmllcyIsImNyZWF0ZVNhbml0aXplciIsImZpbmFsQ29uZmlnIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9lbGVjdHJvbi91dGlscy9sb2dnaW5nL0xvZ1Nhbml0aXplci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIExvZ1Nhbml0aXplci5qc1xuICogXG4gKiBQcm92aWRlcyB1dGlsaXRpZXMgZm9yIHNhbml0aXppbmcgb2JqZWN0cyBiZWZvcmUgbG9nZ2luZywgaGFuZGxpbmcgY29tbW9uIFxuICogY2FzZXMgbGlrZSBCdWZmZXJzLCBjaXJjdWxhciByZWZlcmVuY2VzLCBhbmQgZGVlcGx5IG5lc3RlZCBvYmplY3RzLlxuICogXG4gKiBJbXBsZW1lbnRzIGEgdGllcmVkIGJ1ZmZlciBzYW5pdGl6YXRpb24gYXBwcm9hY2ggdG8gcHJldmVudDpcbiAqIC0gVjggXCJJbnZhbGlkIHN0cmluZyBsZW5ndGhcIiBlcnJvcnMgZnJvbSBsYXJnZSBidWZmZXJzICg+NTEyTUIpXG4gKiAtIE1lbW9yeSBpc3N1ZXMgZnJvbSBleGNlc3NpdmUgYnVmZmVyIGRhdGEgaW4gbG9nc1xuICogLSBMb3NzIG9mIGNyaXRpY2FsIGRlYnVnZ2luZyBpbmZvcm1hdGlvblxuICogXG4gKiBCdWZmZXIgU2l6ZSBUaWVyczpcbiAqIC0gU21hbGwgKDwxTUIpOiBJbmNsdWRlIHRydW5jYXRlZCBwcmV2aWV3IG9mIGJ1ZmZlciBkYXRhXG4gKiAtIE1lZGl1bSAoMS01ME1CKTogSW5jbHVkZSBvbmx5IG1ldGFkYXRhIChzaXplLCB0eXBlLCBoYXNoKVxuICogLSBMYXJnZSAoPjUwTUIpOiBCYXNpYyBtZXRhZGF0YSBvbmx5XG4gKiBcbiAqIFJlbGF0ZWQgRmlsZXM6XG4gKiAtIHNyYy9lbGVjdHJvbi91dGlscy9sb2dnaW5nL0NvbnZlcnNpb25Mb2dnZXIuanNcbiAqIC0gc3JjL2VsZWN0cm9uL2NvbnZlcnRlcnMvVW5pZmllZENvbnZlcnRlckZhY3RvcnkuanNcbiAqIC0gc3JjL2VsZWN0cm9uL3NlcnZpY2VzL2NvbnZlcnNpb24vbXVsdGltZWRpYS9WaWRlb0NvbnZlcnRlci5qc1xuICovXG5cbmNvbnN0IGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpO1xuXG4vLyBCdWZmZXIgc2l6ZSB0aHJlc2hvbGRzIGluIGJ5dGVzXG5jb25zdCBCVUZGRVJfVEhSRVNIT0xEUyA9IHtcbiAgU01BTEw6IDEwMjQgKiAxMDI0LCAvLyAxTUJcbiAgTUVESVVNOiA1MCAqIDEwMjQgKiAxMDI0IC8vIDUwTUJcbn07XG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIHNhbml0aXphdGlvbiBvcHRpb25zXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBTYW5pdGl6ZUNvbmZpZ1xuICogQHByb3BlcnR5IHtudW1iZXJ9IG1heERlcHRoIC0gTWF4aW11bSBkZXB0aCBmb3IgbmVzdGVkIG9iamVjdCB0cmF2ZXJzYWwgXG4gKiBAcHJvcGVydHkge251bWJlcn0gbWF4TGVuZ3RoIC0gTWF4aW11bSBsZW5ndGggZm9yIGFycmF5L2J1ZmZlciBwcmV2aWV3XG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IHRydW5jYXRlQnVmZmVycyAtIFdoZXRoZXIgdG8gdHJ1bmNhdGUgYnVmZmVyIGNvbnRlbnRzXG4gKiBAcHJvcGVydHkge251bWJlcn0gcHJldmlld0xlbmd0aCAtIE1heGltdW0gbGVuZ3RoIG9mIGJ1ZmZlciBkYXRhIHByZXZpZXdcbiAqL1xuXG4vKiogQHR5cGUge1Nhbml0aXplQ29uZmlnfSAqL1xuY29uc3QgREVGQVVMVF9DT05GSUcgPSB7XG4gIG1heERlcHRoOiAzLFxuICBtYXhMZW5ndGg6IDEwMCxcbiAgdHJ1bmNhdGVCdWZmZXJzOiB0cnVlLFxuICBwcmV2aWV3TGVuZ3RoOiA1MCAvLyBEZWZhdWx0IHByZXZpZXcgbGVuZ3RoIGZvciBzbWFsbCBidWZmZXJzXG59O1xuXG4vKipcbiAqIERldGVybWluZXMgdGhlIGFwcHJvcHJpYXRlIHNhbml0aXphdGlvbiBzdHJhdGVneSBiYXNlZCBvbiBidWZmZXIgc2l6ZVxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZmZlciAtIFRoZSBidWZmZXIgdG8gY2xhc3NpZnlcbiAqIEByZXR1cm5zIHsnc21hbGwnfCdtZWRpdW0nfCdsYXJnZSd9IFRoZSBzaXplIGNsYXNzaWZpY2F0aW9uXG4gKi9cbmZ1bmN0aW9uIGNsYXNzaWZ5QnVmZmVyU2l6ZShidWZmZXIpIHtcbiAgY29uc3Qgc2l6ZSA9IGJ1ZmZlci5sZW5ndGg7XG4gIGlmIChzaXplIDwgQlVGRkVSX1RIUkVTSE9MRFMuU01BTEwpIHJldHVybiAnc21hbGwnO1xuICBpZiAoc2l6ZSA8IEJVRkZFUl9USFJFU0hPTERTLk1FRElVTSkgcmV0dXJuICdtZWRpdW0nO1xuICByZXR1cm4gJ2xhcmdlJztcbn1cblxuLyoqXG4gKiBFeHRyYWN0cyBtZXRhZGF0YSBmcm9tIGEgYnVmZmVyIGZvciBsb2dnaW5nXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmZmVyIC0gVGhlIGJ1ZmZlciB0byBleHRyYWN0IG1ldGFkYXRhIGZyb21cbiAqIEByZXR1cm5zIHtPYmplY3R9IEJ1ZmZlciBtZXRhZGF0YVxuICovXG5mdW5jdGlvbiBleHRyYWN0QnVmZmVyTWV0YWRhdGEoYnVmZmVyKSB7XG4gIC8vIENhbGN1bGF0ZSBhIGhhc2ggb2YgdGhlIGZpcnN0IDE2S0IgdG8gaGVscCBpZGVudGlmeSBjb250ZW50XG4gIC8vIHdpdGhvdXQgcHJvY2Vzc2luZyB0aGUgZW50aXJlIGJ1ZmZlclxuICBjb25zdCBoYXNoID0gY3J5cHRvXG4gICAgLmNyZWF0ZUhhc2goJ3NoYTI1NicpXG4gICAgLnVwZGF0ZShidWZmZXIuc2xpY2UoMCwgMTYzODQpKVxuICAgIC5kaWdlc3QoJ2hleCcpXG4gICAgLnNsaWNlKDAsIDE2KTsgLy8gRmlyc3QgMTYgY2hhcnMgb2YgaGFzaCBpcyBzdWZmaWNpZW50XG5cbiAgcmV0dXJuIHtcbiAgICBzaXplOiBidWZmZXIubGVuZ3RoLFxuICAgIHNpemVGb3JtYXR0ZWQ6IGZvcm1hdFNpemUoYnVmZmVyLmxlbmd0aCksXG4gICAgdHlwZTogZGV0ZWN0QnVmZmVyVHlwZShidWZmZXIpLFxuICAgIGhhc2hcbiAgfTtcbn1cblxuLyoqXG4gKiBGb3JtYXRzIGEgYnl0ZSBzaXplIGludG8gYSBodW1hbi1yZWFkYWJsZSBzdHJpbmdcbiAqIEBwYXJhbSB7bnVtYmVyfSBieXRlcyAtIFRoZSBzaXplIGluIGJ5dGVzXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBGb3JtYXR0ZWQgc2l6ZSBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gZm9ybWF0U2l6ZShieXRlcykge1xuICBjb25zdCB1bml0cyA9IFsnQicsICdLQicsICdNQicsICdHQiddO1xuICBsZXQgc2l6ZSA9IGJ5dGVzO1xuICBsZXQgdW5pdEluZGV4ID0gMDtcbiAgXG4gIHdoaWxlIChzaXplID49IDEwMjQgJiYgdW5pdEluZGV4IDwgdW5pdHMubGVuZ3RoIC0gMSkge1xuICAgIHNpemUgLz0gMTAyNDtcbiAgICB1bml0SW5kZXgrKztcbiAgfVxuICBcbiAgcmV0dXJuIGAke3NpemUudG9GaXhlZCgxKX0ke3VuaXRzW3VuaXRJbmRleF19YDtcbn1cblxuLyoqXG4gKiBBdHRlbXB0cyB0byBkZXRlY3QgdGhlIHR5cGUgb2YgZGF0YSBpbiBhIGJ1ZmZlclxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZmZlciAtIFRoZSBidWZmZXIgdG8gYW5hbHl6ZVxuICogQHJldHVybnMge3N0cmluZ30gRGV0ZWN0ZWQgdHlwZSBkZXNjcmlwdGlvblxuICovXG5mdW5jdGlvbiBkZXRlY3RCdWZmZXJUeXBlKGJ1ZmZlcikge1xuICAvLyBDaGVjayBmaWxlIHNpZ25hdHVyZXMvbWFnaWMgbnVtYmVyc1xuICBpZiAoYnVmZmVyLmxlbmd0aCA8IDQpIHJldHVybiAndW5rbm93bic7XG4gIFxuICBjb25zdCBoZWFkZXIgPSBidWZmZXIuc2xpY2UoMCwgNCkudG9TdHJpbmcoJ2hleCcpO1xuICBcbiAgLy8gQ29tbW9uIGZpbGUgc2lnbmF0dXJlc1xuICBpZiAoaGVhZGVyLnN0YXJ0c1dpdGgoJzg5NTA0ZTQ3JykpIHJldHVybiAnaW1hZ2UvcG5nJztcbiAgaWYgKGhlYWRlci5zdGFydHNXaXRoKCdmZmQ4ZmYnKSkgcmV0dXJuICdpbWFnZS9qcGVnJztcbiAgaWYgKGhlYWRlci5zdGFydHNXaXRoKCc0NzQ5NDYzOCcpKSByZXR1cm4gJ2ltYWdlL2dpZic7XG4gIGlmIChoZWFkZXIuc3RhcnRzV2l0aCgnNTI0OTQ2NDYnKSkgcmV0dXJuICd2aWRlby93ZWJtJztcbiAgXG4gIC8vIFRyeSB0byBkZXRlY3QgaWYgaXQncyBVVEYtOCB0ZXh0XG4gIHRyeSB7XG4gICAgY29uc3Qgc2FtcGxlID0gYnVmZmVyLnNsaWNlKDAsIDMyKS50b1N0cmluZygndXRmOCcpO1xuICAgIGlmICgvXltcXHgyMC1cXHg3RlxcblxcclxcdF0qJC8udGVzdChzYW1wbGUpKSByZXR1cm4gJ3RleHQvcGxhaW4nO1xuICB9IGNhdGNoIHt9XG4gIFxuICByZXR1cm4gJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbSc7XG59XG5cbi8qKlxuICogU2FuaXRpemVzIGFuIG9iamVjdCBmb3IgbG9nZ2luZyBieSBoYW5kbGluZyBzcGVjaWFsIGNhc2VzIGFuZCBwcmV2ZW50aW5nIGlzc3Vlc1xuICogQHBhcmFtIHthbnl9IG9iaiAtIFRoZSBvYmplY3QgdG8gc2FuaXRpemVcbiAqIEBwYXJhbSB7U2FuaXRpemVDb25maWd9IFtjb25maWddIC0gQ29uZmlndXJhdGlvbiBvcHRpb25zXG4gKiBAcmV0dXJucyB7YW55fSAtIFRoZSBzYW5pdGl6ZWQgb2JqZWN0IHNhZmUgZm9yIGxvZ2dpbmdcbiAqL1xuZnVuY3Rpb24gc2FuaXRpemVGb3JMb2dnaW5nKG9iaiwgY29uZmlnID0gREVGQVVMVF9DT05GSUcpIHtcbiAgLy8gVXNlIFdlYWtTZXQgdG8gdHJhY2sgb2JqZWN0IHJlZmVyZW5jZXMgYW5kIHByZXZlbnQgY2lyY3VsYXIgcmVjdXJzaW9uXG4gIGNvbnN0IHNlZW4gPSBuZXcgV2Vha1NldCgpO1xuICBcbiAgLyoqXG4gICAqIEludGVybmFsIHJlY3Vyc2l2ZSBzYW5pdGl6YXRpb24gZnVuY3Rpb24gd2l0aCBkZXB0aCB0cmFja2luZ1xuICAgKiBAcGFyYW0ge2FueX0gdmFsdWUgLSBWYWx1ZSB0byBzYW5pdGl6ZVxuICAgKiBAcGFyYW0ge251bWJlcn0gZGVwdGggLSBDdXJyZW50IHJlY3Vyc2lvbiBkZXB0aFxuICAgKiBAcmV0dXJucyB7YW55fSAtIFNhbml0aXplZCB2YWx1ZVxuICAgKi9cbiAgZnVuY3Rpb24gc2FuaXRpemVWYWx1ZSh2YWx1ZSwgZGVwdGggPSAwKSB7XG4gICAgLy8gSGFuZGxlIG51bGwvdW5kZWZpbmVkXG4gICAgaWYgKHZhbHVlID09IG51bGwpIHJldHVybiB2YWx1ZTtcblxuICAgIC8vIEhhbmRsZSBCdWZmZXJzIHVzaW5nIHRpZXJlZCBhcHByb2FjaFxuICAgIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsdWUpKSB7XG4gICAgICBjb25zdCBzaXplQ2xhc3MgPSBjbGFzc2lmeUJ1ZmZlclNpemUodmFsdWUpO1xuICAgICAgY29uc3QgbWV0YWRhdGEgPSBleHRyYWN0QnVmZmVyTWV0YWRhdGEodmFsdWUpO1xuXG4gICAgICAvLyBBcHBseSB0aWVyZWQgc2FuaXRpemF0aW9uIHN0cmF0ZWd5XG4gICAgICBzd2l0Y2ggKHNpemVDbGFzcykge1xuICAgICAgICBjYXNlICdzbWFsbCc6XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdbQnVmZmVyXScsXG4gICAgICAgICAgICAuLi5tZXRhZGF0YSxcbiAgICAgICAgICAgIHByZXZpZXc6IHZhbHVlLnNsaWNlKDAsIGNvbmZpZy5wcmV2aWV3TGVuZ3RoKS50b1N0cmluZygnaGV4JylcbiAgICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgY2FzZSAnbWVkaXVtJzpcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ1tCdWZmZXJdJyxcbiAgICAgICAgICAgIC4uLm1ldGFkYXRhXG4gICAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIGNhc2UgJ2xhcmdlJzpcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ1tMYXJnZSBCdWZmZXJdJyxcbiAgICAgICAgICAgIHNpemU6IG1ldGFkYXRhLnNpemUsXG4gICAgICAgICAgICBzaXplRm9ybWF0dGVkOiBtZXRhZGF0YS5zaXplRm9ybWF0dGVkXG4gICAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgcHJpbWl0aXZlIHR5cGVzXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBmb3IgY2lyY3VsYXIgcmVmZXJlbmNlc1xuICAgIGlmIChzZWVuLmhhcyh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiAnW0NpcmN1bGFyIFJlZmVyZW5jZV0nO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGRlcHRoIGxpbWl0XG4gICAgaWYgKGRlcHRoID49IGNvbmZpZy5tYXhEZXB0aCkge1xuICAgICAgcmV0dXJuICdbTWF4IERlcHRoIFJlYWNoZWRdJztcbiAgICB9XG5cbiAgICAvLyBUcmFjayB0aGlzIG9iamVjdCB0byBkZXRlY3QgY2lyY3VsYXIgcmVmc1xuICAgIHNlZW4uYWRkKHZhbHVlKTtcblxuICAgIC8vIEhhbmRsZSBhcnJheXNcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIGNvbnN0IHNhbml0aXplZEFycmF5ID0gdmFsdWUuc2xpY2UoMCwgY29uZmlnLm1heExlbmd0aCkubWFwKGl0ZW0gPT4gXG4gICAgICAgIHNhbml0aXplVmFsdWUoaXRlbSwgZGVwdGggKyAxKVxuICAgICAgKTtcbiAgICAgIGlmICh2YWx1ZS5sZW5ndGggPiBjb25maWcubWF4TGVuZ3RoKSB7XG4gICAgICAgIHNhbml0aXplZEFycmF5LnB1c2goYC4uLiR7dmFsdWUubGVuZ3RoIC0gY29uZmlnLm1heExlbmd0aH0gbW9yZSBpdGVtc2ApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNhbml0aXplZEFycmF5O1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSBzcGVjaWFsIE5vZGUuanMgb2JqZWN0c1xuICAgIGlmICh2YWx1ZS5faGFuZGxlIHx8IHZhbHVlLl9yZWFkYWJsZVN0YXRlIHx8IHZhbHVlLl93cml0YWJsZVN0YXRlKSB7XG4gICAgICByZXR1cm4gJ1tTdHJlYW0vSGFuZGxlXSc7XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIHJlZ3VsYXIgb2JqZWN0c1xuICAgIGNvbnN0IHNhbml0aXplZCA9IHt9O1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsXSBvZiBPYmplY3QuZW50cmllcyh2YWx1ZSkpIHtcbiAgICAgIHNhbml0aXplZFtrZXldID0gc2FuaXRpemVWYWx1ZSh2YWwsIGRlcHRoICsgMSk7XG4gICAgfVxuICAgIHJldHVybiBzYW5pdGl6ZWQ7XG4gIH1cblxuICByZXR1cm4gc2FuaXRpemVWYWx1ZShvYmopO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBzYW5pdGl6ZXIgd2l0aCBjdXN0b20gY29uZmlndXJhdGlvblxuICogQHBhcmFtIHtTYW5pdGl6ZUNvbmZpZ30gY29uZmlnIC0gQ3VzdG9tIGNvbmZpZ3VyYXRpb24gb3B0aW9uc1xuICogQHJldHVybnMge2Z1bmN0aW9uKGFueSk6IGFueX0gLSBDb25maWd1cmVkIHNhbml0aXplciBmdW5jdGlvblxuICovXG5mdW5jdGlvbiBjcmVhdGVTYW5pdGl6ZXIoY29uZmlnKSB7XG4gIGNvbnN0IGZpbmFsQ29uZmlnID0geyAuLi5ERUZBVUxUX0NPTkZJRywgLi4uY29uZmlnIH07XG4gIHJldHVybiAob2JqKSA9PiBzYW5pdGl6ZUZvckxvZ2dpbmcob2JqLCBmaW5hbENvbmZpZyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBzYW5pdGl6ZUZvckxvZ2dpbmcsXG4gIGNyZWF0ZVNhbml0aXplcixcbiAgREVGQVVMVF9DT05GSUcsXG4gIEJVRkZFUl9USFJFU0hPTERTXG59OyJdLCJtYXBwaW5ncyI6Ijs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsTUFBTUEsTUFBTSxHQUFHQyxPQUFPLENBQUMsUUFBUSxDQUFDOztBQUVoQztBQUNBLE1BQU1DLGlCQUFpQixHQUFHO0VBQ3hCQyxLQUFL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