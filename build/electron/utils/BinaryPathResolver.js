"use strict";

/**
 * BinaryPathResolver.js
 * 
 * Utility module for reliably locating FFmpeg and other binaries in both development
 * and production environments. This module helps fix the "Conversion produced empty content"
 * error in video processing by ensuring binaries are correctly located regardless of
 * environment or platform.
 * 
 * Features:
 * - Multiple resolution strategies with fallbacks
 * - Cross-platform path handling (Windows, macOS, Linux)
 * - Caching mechanism to optimize repeated lookups
 * - Binary verification to confirm existence and executability
 * - Detailed logging for troubleshooting
 * 
 * Related Files:
 * - VideoConverter.js: Uses this module to locate FFmpeg binaries
 * - AudioConverter.js: Uses this module to locate FFmpeg binaries
 * - afterPack.js: Handles binary copying during packaging
 */

const path = require('path');
const fs = require('fs-extra');
const {
  app
} = require('electron');
const os = require('os');

// Cache for resolved binary paths to avoid repeated lookups
const pathCache = new Map();

/**
 * Resolves the path to a binary executable using multiple resolution strategies
 * @param {string} binaryName - Name of the binary to resolve (e.g., 'ffmpeg', 'ffprobe')
 * @param {Object} options - Additional options
 * @param {boolean} options.forceRefresh - Whether to bypass the cache and force a fresh resolution
 * @param {string[]} options.customPaths - Additional custom paths to check
 * @returns {string|null} The resolved path to the binary or null if not found
 */
function resolveBinaryPath(binaryName, options = {}) {
  const {
    forceRefresh = false,
    customPaths = []
  } = options;

  // Normalize binary name based on platform
  const normalizedBinaryName = normalizeBinaryName(binaryName);
  const cacheKey = normalizedBinaryName;

  // Return cached path if available and not forcing refresh
  if (!forceRefresh && pathCache.has(cacheKey)) {
    const cachedPath = pathCache.get(cacheKey);
    console.log(`[BinaryPathResolver] Using cached path for ${normalizedBinaryName}: ${cachedPath}`);
    return cachedPath;
  }
  console.log(`[BinaryPathResolver] Resolving path for binary: ${normalizedBinaryName}`);

  // Determine if we're in production environment
  const isProduction = process.env.NODE_ENV === 'production' || app && app.isPackaged;
  console.log(`[BinaryPathResolver] Environment: ${isProduction ? 'Production' : 'Development'}`);

  // Get platform-specific paths to check
  const pathsToCheck = getPathsToCheck(normalizedBinaryName, isProduction, customPaths);

  // Try each path until we find one that exists and is executable
  for (const binPath of pathsToCheck) {
    try {
      if (verifyBinary(binPath)) {
        console.log(`[BinaryPathResolver] Successfully resolved ${normalizedBinaryName} at: ${binPath}`);
        // Cache the successful path
        pathCache.set(cacheKey, binPath);
        return binPath;
      }
    } catch (error) {
      // Just continue to the next path
      console.log(`[BinaryPathResolver] Path ${binPath} failed verification: ${error.message}`);
    }
  }

  // If we get here, we couldn't find the binary
  console.error(`[BinaryPathResolver] Failed to resolve path for ${normalizedBinaryName}`);
  return null;
}

/**
 * Normalizes binary name based on platform (adds .exe for Windows)
 * @param {string} binaryName - Name of the binary
 * @returns {string} Normalized binary name
 */
function normalizeBinaryName(binaryName) {
  const platform = os.platform();
  if (platform === 'win32' && !binaryName.endsWith('.exe')) {
    return `${binaryName}.exe`;
  }
  return binaryName;
}

/**
 * Gets a list of paths to check for the binary based on environment and platform
 * @param {string} binaryName - Name of the binary
 * @param {boolean} isProduction - Whether we're in production mode
 * @param {string[]} customPaths - Additional custom paths to check
 * @returns {string[]} Array of paths to check in priority order
 */
function getPathsToCheck(binaryName, isProduction, customPaths = []) {
  const platform = os.platform();
  const paths = [];

  // Add custom paths first (highest priority)
  if (customPaths && customPaths.length > 0) {
    paths.push(...customPaths);
  }

  // Production paths - FFmpeg and FFprobe are no longer required
  if (isProduction) {
    console.log('[BinaryPathResolver] FFmpeg and FFprobe binaries are no longer required in production');
  }

  // Development paths
  if (!isProduction) {
    try {
      // FFmpeg and FFprobe are no longer required for the application
      console.log('[BinaryPathResolver] FFmpeg and FFprobe are no longer required');

      // FFmpeg and FFprobe paths are no longer needed
    } catch (error) {
      console.error('[BinaryPathResolver] Error resolving development paths:', error);
    }
  }

  // No system paths needed as FFmpeg and FFprobe are no longer required

  // Log all paths we're going to check
  console.log(`[BinaryPathResolver] Paths to check for ${binaryName}:`, paths);
  return paths;
}

/**
 * Verifies that a binary exists and is executable
 * @param {string} binaryPath - Path to the binary
 * @returns {boolean} True if the binary exists and is executable
 * @throws {Error} If the binary doesn't exist or isn't executable
 */
function verifyBinary(binaryPath) {
  if (!binaryPath) {
    throw new Error('Binary path is empty or undefined');
  }
  try {
    // Check if file exists
    if (!fs.existsSync(binaryPath)) {
      throw new Error(`Binary does not exist at path: ${binaryPath}`);
    }

    // Get file stats
    const stats = fs.statSync(binaryPath);

    // Check if it's a file (not a directory)
    if (!stats.isFile()) {
      throw new Error(`Path exists but is not a file: ${binaryPath}`);
    }

    // On Unix-like systems, check if the file is executable
    const platform = os.platform();
    if (platform !== 'win32') {
      // Check if file has execute permission (Unix-like systems)
      const isExecutable = !!(stats.mode & 0o111); // Check if any execute bit is set
      if (!isExecutable) {
        throw new Error(`Binary exists but is not executable: ${binaryPath}`);
      }
    }

    // Log file details for debugging
    console.log(`[BinaryPathResolver] Verified binary at ${binaryPath}`);
    console.log(`[BinaryPathResolver] File size: ${stats.size} bytes`);
    console.log(`[BinaryPathResolver] File permissions: ${stats.mode.toString(8)}`);
    console.log(`[BinaryPathResolver] Last modified: ${stats.mtime}`);
    return true;
  } catch (error) {
    throw new Error(`Binary verification failed: ${error.message}`);
  }
}

/**
 * Clears the path cache
 */
function clearPathCache() {
  pathCache.clear();
  console.log('[BinaryPathResolver] Path cache cleared');
}

/**
 * Gets the current state of the path cache
 * @returns {Object} Object with binary names as keys and resolved paths as values
 */
function getPathCache() {
  const cache = {};
  for (const [key, value] of pathCache.entries()) {
    cache[key] = value;
  }
  return cache;
}
module.exports = {
  resolveBinaryPath,
  verifyBinary,
  clearPathCache,
  getPathCache
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJwYXRoIiwicmVxdWlyZSIsImZzIiwiYXBwIiwib3MiLCJwYXRoQ2FjaGUiLCJNYXAiLCJyZXNvbHZlQmluYXJ5UGF0aCIsImJpbmFyeU5hbWUiLCJvcHRpb25zIiwiZm9yY2VSZWZyZXNoIiwiY3VzdG9tUGF0aHMiLCJub3JtYWxpemVkQmluYXJ5TmFtZSIsIm5vcm1hbGl6ZUJpbmFyeU5hbWUiLCJjYWNoZUtleSIsImhhcyIsImNhY2hlZFBhdGgiLCJnZXQiLCJjb25zb2xlIiwibG9nIiwiaXNQcm9kdWN0aW9uIiwicHJvY2VzcyIsImVudiIsIk5PREVfRU5WIiwiaXNQYWNrYWdlZCIsInBhdGhzVG9DaGVjayIsImdldFBhdGhzVG9DaGVjayIsImJpblBhdGgiLCJ2ZXJpZnlCaW5hcnkiLCJzZXQiLCJlcnJvciIsIm1lc3NhZ2UiLCJwbGF0Zm9ybSIsImVuZHNXaXRoIiwicGF0aHMiLCJsZW5ndGgiLCJwdXNoIiwiYmluYXJ5UGF0aCIsIkVycm9yIiwiZXhpc3RzU3luYyIsInN0YXRzIiwic3RhdFN5bmMiLCJpc0ZpbGUiLCJpc0V4ZWN1dGFibGUiLCJtb2RlIiwic2l6ZSIsInRvU3RyaW5nIiwibXRpbWUiLCJjbGVhclBhdGhDYWNoZSIsImNsZWFyIiwiZ2V0UGF0aENhY2hlIiwiY2FjaGUiLCJrZXkiLCJ2YWx1ZSIsImVudHJpZXMiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2VsZWN0cm9uL3V0aWxzL0JpbmFyeVBhdGhSZXNvbHZlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEJpbmFyeVBhdGhSZXNvbHZlci5qc1xuICogXG4gKiBVdGlsaXR5IG1vZHVsZSBmb3IgcmVsaWFibHkgbG9jYXRpbmcgRkZtcGVnIGFuZCBvdGhlciBiaW5hcmllcyBpbiBib3RoIGRldmVsb3BtZW50XG4gKiBhbmQgcHJvZHVjdGlvbiBlbnZpcm9ubWVudHMuIFRoaXMgbW9kdWxlIGhlbHBzIGZpeCB0aGUgXCJDb252ZXJzaW9uIHByb2R1Y2VkIGVtcHR5IGNvbnRlbnRcIlxuICogZXJyb3IgaW4gdmlkZW8gcHJvY2Vzc2luZyBieSBlbnN1cmluZyBiaW5hcmllcyBhcmUgY29ycmVjdGx5IGxvY2F0ZWQgcmVnYXJkbGVzcyBvZlxuICogZW52aXJvbm1lbnQgb3IgcGxhdGZvcm0uXG4gKiBcbiAqIEZlYXR1cmVzOlxuICogLSBNdWx0aXBsZSByZXNvbHV0aW9uIHN0cmF0ZWdpZXMgd2l0aCBmYWxsYmFja3NcbiAqIC0gQ3Jvc3MtcGxhdGZvcm0gcGF0aCBoYW5kbGluZyAoV2luZG93cywgbWFjT1MsIExpbnV4KVxuICogLSBDYWNoaW5nIG1lY2hhbmlzbSB0byBvcHRpbWl6ZSByZXBlYXRlZCBsb29rdXBzXG4gKiAtIEJpbmFyeSB2ZXJpZmljYXRpb24gdG8gY29uZmlybSBleGlzdGVuY2UgYW5kIGV4ZWN1dGFiaWxpdHlcbiAqIC0gRGV0YWlsZWQgbG9nZ2luZyBmb3IgdHJvdWJsZXNob290aW5nXG4gKiBcbiAqIFJlbGF0ZWQgRmlsZXM6XG4gKiAtIFZpZGVvQ29udmVydGVyLmpzOiBVc2VzIHRoaXMgbW9kdWxlIHRvIGxvY2F0ZSBGRm1wZWcgYmluYXJpZXNcbiAqIC0gQXVkaW9Db252ZXJ0ZXIuanM6IFVzZXMgdGhpcyBtb2R1bGUgdG8gbG9jYXRlIEZGbXBlZyBiaW5hcmllc1xuICogLSBhZnRlclBhY2suanM6IEhhbmRsZXMgYmluYXJ5IGNvcHlpbmcgZHVyaW5nIHBhY2thZ2luZ1xuICovXG5cbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG5jb25zdCBmcyA9IHJlcXVpcmUoJ2ZzLWV4dHJhJyk7XG5jb25zdCB7IGFwcCB9ID0gcmVxdWlyZSgnZWxlY3Ryb24nKTtcbmNvbnN0IG9zID0gcmVxdWlyZSgnb3MnKTtcblxuLy8gQ2FjaGUgZm9yIHJlc29sdmVkIGJpbmFyeSBwYXRocyB0byBhdm9pZCByZXBlYXRlZCBsb29rdXBzXG5jb25zdCBwYXRoQ2FjaGUgPSBuZXcgTWFwKCk7XG5cbi8qKlxuICogUmVzb2x2ZXMgdGhlIHBhdGggdG8gYSBiaW5hcnkgZXhlY3V0YWJsZSB1c2luZyBtdWx0aXBsZSByZXNvbHV0aW9uIHN0cmF0ZWdpZXNcbiAqIEBwYXJhbSB7c3RyaW5nfSBiaW5hcnlOYW1lIC0gTmFtZSBvZiB0aGUgYmluYXJ5IHRvIHJlc29sdmUgKGUuZy4sICdmZm1wZWcnLCAnZmZwcm9iZScpXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIEFkZGl0aW9uYWwgb3B0aW9uc1xuICogQHBhcmFtIHtib29sZWFufSBvcHRpb25zLmZvcmNlUmVmcmVzaCAtIFdoZXRoZXIgdG8gYnlwYXNzIHRoZSBjYWNoZSBhbmQgZm9yY2UgYSBmcmVzaCByZXNvbHV0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBvcHRpb25zLmN1c3RvbVBhdGhzIC0gQWRkaXRpb25hbCBjdXN0b20gcGF0aHMgdG8gY2hlY2tcbiAqIEByZXR1cm5zIHtzdHJpbmd8bnVsbH0gVGhlIHJlc29sdmVkIHBhdGggdG8gdGhlIGJpbmFyeSBvciBudWxsIGlmIG5vdCBmb3VuZFxuICovXG5mdW5jdGlvbiByZXNvbHZlQmluYXJ5UGF0aChiaW5hcnlOYW1lLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IGZvcmNlUmVmcmVzaCA9IGZhbHNlLCBjdXN0b21QYXRocyA9IFtdIH0gPSBvcHRpb25zO1xuICAgIFxuICAgIC8vIE5vcm1hbGl6ZSBiaW5hcnkgbmFtZSBiYXNlZCBvbiBwbGF0Zm9ybVxuICAgIGNvbnN0IG5vcm1hbGl6ZWRCaW5hcnlOYW1lID0gbm9ybWFsaXplQmluYXJ5TmFtZShiaW5hcnlOYW1lKTtcbiAgICBjb25zdCBjYWNoZUtleSA9IG5vcm1hbGl6ZWRCaW5hcnlOYW1lO1xuICAgIFxuICAgIC8vIFJldHVybiBjYWNoZWQgcGF0aCBpZiBhdmFpbGFibGUgYW5kIG5vdCBmb3JjaW5nIHJlZnJlc2hcbiAgICBpZiAoIWZvcmNlUmVmcmVzaCAmJiBwYXRoQ2FjaGUuaGFzKGNhY2hlS2V5KSkge1xuICAgICAgICBjb25zdCBjYWNoZWRQYXRoID0gcGF0aENhY2hlLmdldChjYWNoZUtleSk7XG4gICAgICAgIGNvbnNvbGUubG9nKGBbQmluYXJ5UGF0aFJlc29sdmVyXSBVc2luZyBjYWNoZWQgcGF0aCBmb3IgJHtub3JtYWxpemVkQmluYXJ5TmFtZX06ICR7Y2FjaGVkUGF0aH1gKTtcbiAgICAgICAgcmV0dXJuIGNhY2hlZFBhdGg7XG4gICAgfVxuICAgIFxuICAgIGNvbnNvbGUubG9nKGBbQmluYXJ5UGF0aFJlc29sdmVyXSBSZXNvbHZpbmcgcGF0aCBmb3IgYmluYXJ5OiAke25vcm1hbGl6ZWRCaW5hcnlOYW1lfWApO1xuICAgIFxuICAgIC8vIERldGVybWluZSBpZiB3ZSdyZSBpbiBwcm9kdWN0aW9uIGVudmlyb25tZW50XG4gICAgY29uc3QgaXNQcm9kdWN0aW9uID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJyB8fCAoYXBwICYmIGFwcC5pc1BhY2thZ2VkKTtcbiAgICBjb25zb2xlLmxvZyhgW0JpbmFyeVBhdGhSZXNvbHZlcl0gRW52aXJvbm1lbnQ6ICR7aXNQcm9kdWN0aW9uID8gJ1Byb2R1Y3Rpb24nIDogJ0RldmVsb3BtZW50J31gKTtcbiAgICBcbiAgICAvLyBHZXQgcGxhdGZvcm0tc3BlY2lmaWMgcGF0aHMgdG8gY2hlY2tcbiAgICBjb25zdCBwYXRoc1RvQ2hlY2sgPSBnZXRQYXRoc1RvQ2hlY2sobm9ybWFsaXplZEJpbmFyeU5hbWUsIGlzUHJvZHVjdGlvbiwgY3VzdG9tUGF0aHMpO1xuICAgIFxuICAgIC8vIFRyeSBlYWNoIHBhdGggdW50aWwgd2UgZmluZCBvbmUgdGhhdCBleGlzdHMgYW5kIGlzIGV4ZWN1dGFibGVcbiAgICBmb3IgKGNvbnN0IGJpblBhdGggb2YgcGF0aHNUb0NoZWNrKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAodmVyaWZ5QmluYXJ5KGJpblBhdGgpKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYFtCaW5hcnlQYXRoUmVzb2x2ZXJdIFN1Y2Nlc3NmdWxseSByZXNvbHZlZCAke25vcm1hbGl6ZWRCaW5hcnlOYW1lfSBhdDogJHtiaW5QYXRofWApO1xuICAgICAgICAgICAgICAgIC8vIENhY2hlIHRoZSBzdWNjZXNzZnVsIHBhdGhcbiAgICAgICAgICAgICAgICBwYXRoQ2FjaGUuc2V0KGNhY2hlS2V5LCBiaW5QYXRoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYmluUGF0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIC8vIEp1c3QgY29udGludWUgdG8gdGhlIG5leHQgcGF0aFxuICAgICAgICAgICAgY29uc29sZS5sb2coYFtCaW5hcnlQYXRoUmVzb2x2ZXJdIFBhdGggJHtiaW5QYXRofSBmYWlsZWQgdmVyaWZpY2F0aW9uOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gSWYgd2UgZ2V0IGhlcmUsIHdlIGNvdWxkbid0IGZpbmQgdGhlIGJpbmFyeVxuICAgIGNvbnNvbGUuZXJyb3IoYFtCaW5hcnlQYXRoUmVzb2x2ZXJdIEZhaWxlZCB0byByZXNvbHZlIHBhdGggZm9yICR7bm9ybWFsaXplZEJpbmFyeU5hbWV9YCk7XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogTm9ybWFsaXplcyBiaW5hcnkgbmFtZSBiYXNlZCBvbiBwbGF0Zm9ybSAoYWRkcyAuZXhlIGZvciBXaW5kb3dzKVxuICogQHBhcmFtIHtzdHJpbmd9IGJpbmFyeU5hbWUgLSBOYW1lIG9mIHRoZSBiaW5hcnlcbiAqIEByZXR1cm5zIHtzdHJpbmd9IE5vcm1hbGl6ZWQgYmluYXJ5IG5hbWVcbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplQmluYXJ5TmFtZShiaW5hcnlOYW1lKSB7XG4gICAgY29uc3QgcGxhdGZvcm0gPSBvcy5wbGF0Zm9ybSgpO1xuICAgIGlmIChwbGF0Zm9ybSA9PT0gJ3dpbjMyJyAmJiAhYmluYXJ5TmFtZS5lbmRzV2l0aCgnLmV4ZScpKSB7XG4gICAgICAgIHJldHVybiBgJHtiaW5hcnlOYW1lfS5leGVgO1xuICAgIH1cbiAgICByZXR1cm4gYmluYXJ5TmFtZTtcbn1cblxuLyoqXG4gKiBHZXRzIGEgbGlzdCBvZiBwYXRocyB0byBjaGVjayBmb3IgdGhlIGJpbmFyeSBiYXNlZCBvbiBlbnZpcm9ubWVudCBhbmQgcGxhdGZvcm1cbiAqIEBwYXJhbSB7c3RyaW5nfSBiaW5hcnlOYW1lIC0gTmFtZSBvZiB0aGUgYmluYXJ5XG4gKiBAcGFyYW0ge2Jvb2xlYW59IGlzUHJvZHVjdGlvbiAtIFdoZXRoZXIgd2UncmUgaW4gcHJvZHVjdGlvbiBtb2RlXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBjdXN0b21QYXRocyAtIEFkZGl0aW9uYWwgY3VzdG9tIHBhdGhzIHRvIGNoZWNrXG4gKiBAcmV0dXJucyB7c3RyaW5nW119IEFycmF5IG9mIHBhdGhzIHRvIGNoZWNrIGluIHByaW9yaXR5IG9yZGVyXG4gKi9cbmZ1bmN0aW9uIGdldFBhdGhzVG9DaGVjayhiaW5hcnlOYW1lLCBpc1Byb2R1Y3Rpb24sIGN1c3RvbVBhdGhzID0gW10pIHtcbiAgICBjb25zdCBwbGF0Zm9ybSA9IG9zLnBsYXRmb3JtKCk7XG4gICAgY29uc3QgcGF0aHMgPSBbXTtcbiAgICBcbiAgICAvLyBBZGQgY3VzdG9tIHBhdGhzIGZpcnN0IChoaWdoZXN0IHByaW9yaXR5KVxuICAgIGlmIChjdXN0b21QYXRocyAmJiBjdXN0b21QYXRocy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHBhdGhzLnB1c2goLi4uY3VzdG9tUGF0aHMpO1xuICAgIH1cbiAgICBcbiAgICAvLyBQcm9kdWN0aW9uIHBhdGhzIC0gRkZtcGVnIGFuZCBGRnByb2JlIGFyZSBubyBsb25nZXIgcmVxdWlyZWRcbiAgICBpZiAoaXNQcm9kdWN0aW9uKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdbQmluYXJ5UGF0aFJlc29sdmVyXSBGRm1wZWcgYW5kIEZGcHJvYmUgYmluYXJpZXMgYXJlIG5vIGxvbmdlciByZXF1aXJlZCBpbiBwcm9kdWN0aW9uJyk7XG4gICAgfVxuICAgIFxuICAgIC8vIERldmVsb3BtZW50IHBhdGhzXG4gICAgaWYgKCFpc1Byb2R1Y3Rpb24pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIEZGbXBlZyBhbmQgRkZwcm9iZSBhcmUgbm8gbG9uZ2VyIHJlcXVpcmVkIGZvciB0aGUgYXBwbGljYXRpb25cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbQmluYXJ5UGF0aFJlc29sdmVyXSBGRm1wZWcgYW5kIEZGcHJvYmUgYXJlIG5vIGxvbmdlciByZXF1aXJlZCcpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBGRm1wZWcgYW5kIEZGcHJvYmUgcGF0aHMgYXJlIG5vIGxvbmdlciBuZWVkZWRcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1tCaW5hcnlQYXRoUmVzb2x2ZXJdIEVycm9yIHJlc29sdmluZyBkZXZlbG9wbWVudCBwYXRoczonLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gTm8gc3lzdGVtIHBhdGhzIG5lZWRlZCBhcyBGRm1wZWcgYW5kIEZGcHJvYmUgYXJlIG5vIGxvbmdlciByZXF1aXJlZFxuICAgIFxuICAgIC8vIExvZyBhbGwgcGF0aHMgd2UncmUgZ29pbmcgdG8gY2hlY2tcbiAgICBjb25zb2xlLmxvZyhgW0JpbmFyeVBhdGhSZXNvbHZlcl0gUGF0aHMgdG8gY2hlY2sgZm9yICR7YmluYXJ5TmFtZX06YCwgcGF0aHMpO1xuICAgIFxuICAgIHJldHVybiBwYXRocztcbn1cblxuLyoqXG4gKiBWZXJpZmllcyB0aGF0IGEgYmluYXJ5IGV4aXN0cyBhbmQgaXMgZXhlY3V0YWJsZVxuICogQHBhcmFtIHtzdHJpbmd9IGJpbmFyeVBhdGggLSBQYXRoIHRvIHRoZSBiaW5hcnlcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSBiaW5hcnkgZXhpc3RzIGFuZCBpcyBleGVjdXRhYmxlXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIGJpbmFyeSBkb2Vzbid0IGV4aXN0IG9yIGlzbid0IGV4ZWN1dGFibGVcbiAqL1xuZnVuY3Rpb24gdmVyaWZ5QmluYXJ5KGJpbmFyeVBhdGgpIHtcbiAgICBpZiAoIWJpbmFyeVBhdGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdCaW5hcnkgcGF0aCBpcyBlbXB0eSBvciB1bmRlZmluZWQnKTtcbiAgICB9XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgICAgLy8gQ2hlY2sgaWYgZmlsZSBleGlzdHNcbiAgICAgICAgaWYgKCFmcy5leGlzdHNTeW5jKGJpbmFyeVBhdGgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEJpbmFyeSBkb2VzIG5vdCBleGlzdCBhdCBwYXRoOiAke2JpbmFyeVBhdGh9YCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIEdldCBmaWxlIHN0YXRzXG4gICAgICAgIGNvbnN0IHN0YXRzID0gZnMuc3RhdFN5bmMoYmluYXJ5UGF0aCk7XG4gICAgICAgIFxuICAgICAgICAvLyBDaGVjayBpZiBpdCdzIGEgZmlsZSAobm90IGEgZGlyZWN0b3J5KVxuICAgICAgICBpZiAoIXN0YXRzLmlzRmlsZSgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFBhdGggZXhpc3RzIGJ1dCBpcyBub3QgYSBmaWxlOiAke2JpbmFyeVBhdGh9YCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIE9uIFVuaXgtbGlrZSBzeXN0ZW1zLCBjaGVjayBpZiB0aGUgZmlsZSBpcyBleGVjdXRhYmxlXG4gICAgICAgIGNvbnN0IHBsYXRmb3JtID0gb3MucGxhdGZvcm0oKTtcbiAgICAgICAgaWYgKHBsYXRmb3JtICE9PSAnd2luMzInKSB7XG4gICAgICAgICAgICAvLyBDaGVjayBpZiBmaWxlIGhhcyBleGVjdXRlIHBlcm1pc3Npb24gKFVuaXgtbGlrZSBzeXN0ZW1zKVxuICAgICAgICAgICAgY29uc3QgaXNFeGVjdXRhYmxlID0gISEoc3RhdHMubW9kZSAmIDBvMTExKTsgLy8gQ2hlY2sgaWYgYW55IGV4ZWN1dGUgYml0IGlzIHNldFxuICAgICAgICAgICAgaWYgKCFpc0V4ZWN1dGFibGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEJpbmFyeSBleGlzdHMgYnV0IGlzIG5vdCBleGVjdXRhYmxlOiAke2JpbmFyeVBhdGh9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIExvZyBmaWxlIGRldGFpbHMgZm9yIGRlYnVnZ2luZ1xuICAgICAgICBjb25zb2xlLmxvZyhgW0JpbmFyeVBhdGhSZXNvbHZlcl0gVmVyaWZpZWQgYmluYXJ5IGF0ICR7YmluYXJ5UGF0aH1gKTtcbiAgICAgICAgY29uc29sZS5sb2coYFtCaW5hcnlQYXRoUmVzb2x2ZXJdIEZpbGUgc2l6ZTogJHtzdGF0cy5zaXplfSBieXRlc2ApO1xuICAgICAgICBjb25zb2xlLmxvZyhgW0JpbmFyeVBhdGhSZXNvbHZlcl0gRmlsZSBwZXJtaXNzaW9uczogJHtzdGF0cy5tb2RlLnRvU3RyaW5nKDgpfWApO1xuICAgICAgICBjb25zb2xlLmxvZyhgW0JpbmFyeVBhdGhSZXNvbHZlcl0gTGFzdCBtb2RpZmllZDogJHtzdGF0cy5tdGltZX1gKTtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQmluYXJ5IHZlcmlmaWNhdGlvbiBmYWlsZWQ6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICB9XG59XG5cbi8qKlxuICogQ2xlYXJzIHRoZSBwYXRoIGNhY2hlXG4gKi9cbmZ1bmN0aW9uIGNsZWFyUGF0aENhY2hlKCkge1xuICAgIHBhdGhDYWNoZS5jbGVhcigpO1xuICAgIGNvbnNvbGUubG9nKCdbQmluYXJ5UGF0aFJlc29sdmVyXSBQYXRoIGNhY2hlIGNsZWFyZWQnKTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBwYXRoIGNhY2hlXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBPYmplY3Qgd2l0aCBiaW5hcnkgbmFtZXMgYXMga2V5cyBhbmQgcmVzb2x2ZWQgcGF0aHMgYXMgdmFsdWVzXG4gKi9cbmZ1bmN0aW9uIGdldFBhdGhDYWNoZSgpIHtcbiAgICBjb25zdCBjYWNoZSA9IHt9O1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHBhdGhDYWNoZS5lbnRyaWVzKCkpIHtcbiAgICAgICAgY2FjaGVba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gY2FjaGU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIHJlc29sdmVCaW5hcnlQYXRoLFxuICAgIHZlcmlmeUJpbmFyeSxcbiAgICBjbGVhclBhdGhDYWNoZSxcbiAgICBnZXRQYXRoQ2FjaGVcbn07Il0sIm1hcHBpbmdzIjoiOztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsTUFBTUEsSUFBSSxHQUFHQyxPQUFPLENBQUMsTUFBTSxDQUFDO0FBQzVCLE1BQU1DLEVBQUUsR0FBR0QsT0FBTyxDQUFDLFVBQVUsQ0FBQztBQUM5QixNQUFNO0VBQUVFO0FBQUksQ0FBQyxHQUFHRixPQUFPLENBQUMsVUFBVSxDQUFDO0FBQ25DLE1BQU1HLEVBQUUsR0FBR0gsT0FBTyxDQUFDLElBQUksQ0FBQzs7QUFFeEI7QUFDQSxNQUFNSSxTQUFTLEdBQUcsSUFBSUMsR0FBRyxDQUFDLENBQUM7O0FBRTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTQyxpQkFBaUJBLENBQUNDLFVBQVUsRUFBRUMsT0FBTyxHQUFHLENBQUMsQ0FBQyxFQUFFO0VBQ2pELE1BQU07SUFBRUMsWUFBWSxHQUFHLEtBQUs7SUFBRUMsV0FB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