"use strict";

/**
 * BinaryPathResolver.js
 * 
 * Utility module for reliably locating FFmpeg and other binaries in both development
 * and production environments. This module helps fix the "Conversion produced empty content"
 * error in video processing by ensuring binaries are correctly located regardless of
 * environment or platform.
 * 
 * Features:
 * - Multiple resolution strategies with fallbacks
 * - Cross-platform path handling (Windows, macOS, Linux)
 * - Caching mechanism to optimize repeated lookups
 * - Binary verification to confirm existence and executability
 * - Detailed logging for troubleshooting
 * 
 * Related Files:
 * - VideoConverter.js: Uses this module to locate FFmpeg binaries
 * - AudioConverter.js: Uses this module to locate FFmpeg binaries
 * - afterPack.js: Handles binary copying during packaging
 */

const path = require('path');
const fs = require('fs-extra');
const {
  app
} = require('electron');
const os = require('os');

// Cache for resolved binary paths to avoid repeated lookups
const pathCache = new Map();

/**
 * Resolves the path to a binary executable using multiple resolution strategies
 * @param {string} binaryName - Name of the binary to resolve (e.g., 'ffmpeg', 'ffprobe')
 * @param {Object} options - Additional options
 * @param {boolean} options.forceRefresh - Whether to bypass the cache and force a fresh resolution
 * @param {string[]} options.customPaths - Additional custom paths to check
 * @returns {string|null} The resolved path to the binary or null if not found
 */
function resolveBinaryPath(binaryName, options = {}) {
  const {
    forceRefresh = false,
    customPaths = []
  } = options;

  // Normalize binary name based on platform
  const normalizedBinaryName = normalizeBinaryName(binaryName);
  const cacheKey = normalizedBinaryName;

  // Return cached path if available and not forcing refresh
  if (!forceRefresh && pathCache.has(cacheKey)) {
    const cachedPath = pathCache.get(cacheKey);
    console.log(`[BinaryPathResolver] Using cached path for ${normalizedBinaryName}: ${cachedPath}`);
    return cachedPath;
  }
  console.log(`[BinaryPathResolver] Resolving path for binary: ${normalizedBinaryName}`);

  // Determine if we're in production environment
  const isProduction = process.env.NODE_ENV === 'production' || app && app.isPackaged;
  console.log(`[BinaryPathResolver] Environment: ${isProduction ? 'Production' : 'Development'}`);

  // Get platform-specific paths to check
  const pathsToCheck = getPathsToCheck(normalizedBinaryName, isProduction, customPaths);

  // Try each path until we find one that exists and is executable
  for (const binPath of pathsToCheck) {
    try {
      if (verifyBinary(binPath)) {
        console.log(`[BinaryPathResolver] Successfully resolved ${normalizedBinaryName} at: ${binPath}`);
        // Cache the successful path
        pathCache.set(cacheKey, binPath);
        return binPath;
      }
    } catch (error) {
      // Just continue to the next path
      console.log(`[BinaryPathResolver] Path ${binPath} failed verification: ${error.message}`);
    }
  }

  // If we get here, we couldn't find the binary
  console.error(`[BinaryPathResolver] Failed to resolve path for ${normalizedBinaryName}`);
  return null;
}

/**
 * Normalizes binary name based on platform (adds .exe for Windows)
 * @param {string} binaryName - Name of the binary
 * @returns {string} Normalized binary name
 */
function normalizeBinaryName(binaryName) {
  const platform = os.platform();
  if (platform === 'win32' && !binaryName.endsWith('.exe')) {
    return `${binaryName}.exe`;
  }
  return binaryName;
}

/**
 * Gets a list of paths to check for the binary based on environment and platform
 * @param {string} binaryName - Name of the binary
 * @param {boolean} isProduction - Whether we're in production mode
 * @param {string[]} customPaths - Additional custom paths to check
 * @returns {string[]} Array of paths to check in priority order
 */
function getPathsToCheck(binaryName, isProduction, customPaths = []) {
  const platform = os.platform();
  const paths = [];

  // Add custom paths first (highest priority)
  if (customPaths && customPaths.length > 0) {
    paths.push(...customPaths);
  }

  // Production paths
  if (isProduction) {
    // 1. Check resources directory (extraResources destination)
    if (process.resourcesPath) {
      paths.push(path.join(process.resourcesPath, binaryName));
    }

    // 2. Check app.asar.unpacked paths
    const appPath = app ? app.getAppPath() : null;
    if (appPath) {
      // For asar-packaged apps
      const unpacked = appPath.replace('app.asar', 'app.asar.unpacked');
      paths.push(path.join(unpacked, 'node_modules', '@ffmpeg-installer', 'win32-x64', binaryName));
      paths.push(path.join(unpacked, 'node_modules', 'ffprobe-static', 'bin', platform, 'x64', binaryName));

      // Also check the regular app path
      paths.push(path.join(appPath, 'node_modules', '@ffmpeg-installer', 'win32-x64', binaryName));
      paths.push(path.join(appPath, 'node_modules', 'ffprobe-static', 'bin', platform, 'x64', binaryName));
    }
  }

  // Development paths
  if (!isProduction) {
    try {
      // For ffmpeg
      if (binaryName.includes('ffmpeg')) {
        try {
          const ffmpegInstaller = require('@ffmpeg-installer/ffmpeg');
          paths.push(ffmpegInstaller.path);
        } catch (e) {
          console.error('[BinaryPathResolver] Failed to require @ffmpeg-installer/ffmpeg', e);
        }
      }

      // For ffprobe
      if (binaryName.includes('ffprobe')) {
        try {
          const ffprobeStatic = require('ffprobe-static');
          paths.push(ffprobeStatic.path);
        } catch (e) {
          console.error('[BinaryPathResolver] Failed to require ffprobe-static', e);
        }
      }

      // Check node_modules directly
      const projectRoot = path.resolve(__dirname, '..', '..', '..');
      paths.push(path.join(projectRoot, 'node_modules', '@ffmpeg-installer', 'win32-x64', binaryName));
      paths.push(path.join(projectRoot, 'node_modules', 'ffprobe-static', 'bin', platform, 'x64', binaryName));
    } catch (error) {
      console.error('[BinaryPathResolver] Error resolving development paths:', error);
    }
  }

  // Platform-specific system paths
  if (platform === 'win32') {
    // Windows system paths
    paths.push(path.join(process.env.ProgramFiles || 'C:\\Program Files', 'ffmpeg', 'bin', binaryName));
    paths.push(path.join(process.env['ProgramFiles(x86)'] || 'C:\\Program Files (x86)', 'ffmpeg', 'bin', binaryName));
  } else if (platform === 'darwin') {
    // macOS system paths
    paths.push(`/usr/local/bin/${binaryName}`);
    paths.push(`/opt/homebrew/bin/${binaryName}`);
    paths.push(`/opt/local/bin/${binaryName}`);
  } else {
    // Linux system paths
    paths.push(`/usr/bin/${binaryName}`);
    paths.push(`/usr/local/bin/${binaryName}`);
    paths.push(`/opt/bin/${binaryName}`);
  }

  // Log all paths we're going to check
  console.log(`[BinaryPathResolver] Paths to check for ${binaryName}:`, paths);
  return paths;
}

/**
 * Verifies that a binary exists and is executable
 * @param {string} binaryPath - Path to the binary
 * @returns {boolean} True if the binary exists and is executable
 * @throws {Error} If the binary doesn't exist or isn't executable
 */
function verifyBinary(binaryPath) {
  if (!binaryPath) {
    throw new Error('Binary path is empty or undefined');
  }
  try {
    // Check if file exists
    if (!fs.existsSync(binaryPath)) {
      throw new Error(`Binary does not exist at path: ${binaryPath}`);
    }

    // Get file stats
    const stats = fs.statSync(binaryPath);

    // Check if it's a file (not a directory)
    if (!stats.isFile()) {
      throw new Error(`Path exists but is not a file: ${binaryPath}`);
    }

    // On Unix-like systems, check if the file is executable
    const platform = os.platform();
    if (platform !== 'win32') {
      // Check if file has execute permission (Unix-like systems)
      const isExecutable = !!(stats.mode & 0o111); // Check if any execute bit is set
      if (!isExecutable) {
        throw new Error(`Binary exists but is not executable: ${binaryPath}`);
      }
    }

    // Log file details for debugging
    console.log(`[BinaryPathResolver] Verified binary at ${binaryPath}`);
    console.log(`[BinaryPathResolver] File size: ${stats.size} bytes`);
    console.log(`[BinaryPathResolver] File permissions: ${stats.mode.toString(8)}`);
    console.log(`[BinaryPathResolver] Last modified: ${stats.mtime}`);
    return true;
  } catch (error) {
    throw new Error(`Binary verification failed: ${error.message}`);
  }
}

/**
 * Clears the path cache
 */
function clearPathCache() {
  pathCache.clear();
  console.log('[BinaryPathResolver] Path cache cleared');
}

/**
 * Gets the current state of the path cache
 * @returns {Object} Object with binary names as keys and resolved paths as values
 */
function getPathCache() {
  const cache = {};
  for (const [key, value] of pathCache.entries()) {
    cache[key] = value;
  }
  return cache;
}
module.exports = {
  resolveBinaryPath,
  verifyBinary,
  clearPathCache,
  getPathCache
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJwYXRoIiwicmVxdWlyZSIsImZzIiwiYXBwIiwib3MiLCJwYXRoQ2FjaGUiLCJNYXAiLCJyZXNvbHZlQmluYXJ5UGF0aCIsImJpbmFyeU5hbWUiLCJvcHRpb25zIiwiZm9yY2VSZWZyZXNoIiwiY3VzdG9tUGF0aHMiLCJub3JtYWxpemVkQmluYXJ5TmFtZSIsIm5vcm1hbGl6ZUJpbmFyeU5hbWUiLCJjYWNoZUtleSIsImhhcyIsImNhY2hlZFBhdGgiLCJnZXQiLCJjb25zb2xlIiwibG9nIiwiaXNQcm9kdWN0aW9uIiwicHJvY2VzcyIsImVudiIsIk5PREVfRU5WIiwiaXNQYWNrYWdlZCIsInBhdGhzVG9DaGVjayIsImdldFBhdGhzVG9DaGVjayIsImJpblBhdGgiLCJ2ZXJpZnlCaW5hcnkiLCJzZXQiLCJlcnJvciIsIm1lc3NhZ2UiLCJwbGF0Zm9ybSIsImVuZHNXaXRoIiwicGF0aHMiLCJsZW5ndGgiLCJwdXNoIiwicmVzb3VyY2VzUGF0aCIsImpvaW4iLCJhcHBQYXRoIiwiZ2V0QXBwUGF0aCIsInVucGFja2VkIiwicmVwbGFjZSIsImluY2x1ZGVzIiwiZmZtcGVnSW5zdGFsbGVyIiwiZSIsImZmcHJvYmVTdGF0aWMiLCJwcm9qZWN0Um9vdCIsInJlc29sdmUiLCJfX2Rpcm5hbWUiLCJQcm9ncmFtRmlsZXMiLCJiaW5hcnlQYXRoIiwiRXJyb3IiLCJleGlzdHNTeW5jIiwic3RhdHMiLCJzdGF0U3luYyIsImlzRmlsZSIsImlzRXhlY3V0YWJsZSIsIm1vZGUiLCJzaXplIiwidG9TdHJpbmciLCJtdGltZSIsImNsZWFyUGF0aENhY2hlIiwiY2xlYXIiLCJnZXRQYXRoQ2FjaGUiLCJjYWNoZSIsImtleSIsInZhbHVlIiwiZW50cmllcyIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvZWxlY3Ryb24vdXRpbHMvQmluYXJ5UGF0aFJlc29sdmVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBCaW5hcnlQYXRoUmVzb2x2ZXIuanNcclxuICogXHJcbiAqIFV0aWxpdHkgbW9kdWxlIGZvciByZWxpYWJseSBsb2NhdGluZyBGRm1wZWcgYW5kIG90aGVyIGJpbmFyaWVzIGluIGJvdGggZGV2ZWxvcG1lbnRcclxuICogYW5kIHByb2R1Y3Rpb24gZW52aXJvbm1lbnRzLiBUaGlzIG1vZHVsZSBoZWxwcyBmaXggdGhlIFwiQ29udmVyc2lvbiBwcm9kdWNlZCBlbXB0eSBjb250ZW50XCJcclxuICogZXJyb3IgaW4gdmlkZW8gcHJvY2Vzc2luZyBieSBlbnN1cmluZyBiaW5hcmllcyBhcmUgY29ycmVjdGx5IGxvY2F0ZWQgcmVnYXJkbGVzcyBvZlxyXG4gKiBlbnZpcm9ubWVudCBvciBwbGF0Zm9ybS5cclxuICogXHJcbiAqIEZlYXR1cmVzOlxyXG4gKiAtIE11bHRpcGxlIHJlc29sdXRpb24gc3RyYXRlZ2llcyB3aXRoIGZhbGxiYWNrc1xyXG4gKiAtIENyb3NzLXBsYXRmb3JtIHBhdGggaGFuZGxpbmcgKFdpbmRvd3MsIG1hY09TLCBMaW51eClcclxuICogLSBDYWNoaW5nIG1lY2hhbmlzbSB0byBvcHRpbWl6ZSByZXBlYXRlZCBsb29rdXBzXHJcbiAqIC0gQmluYXJ5IHZlcmlmaWNhdGlvbiB0byBjb25maXJtIGV4aXN0ZW5jZSBhbmQgZXhlY3V0YWJpbGl0eVxyXG4gKiAtIERldGFpbGVkIGxvZ2dpbmcgZm9yIHRyb3VibGVzaG9vdGluZ1xyXG4gKiBcclxuICogUmVsYXRlZCBGaWxlczpcclxuICogLSBWaWRlb0NvbnZlcnRlci5qczogVXNlcyB0aGlzIG1vZHVsZSB0byBsb2NhdGUgRkZtcGVnIGJpbmFyaWVzXHJcbiAqIC0gQXVkaW9Db252ZXJ0ZXIuanM6IFVzZXMgdGhpcyBtb2R1bGUgdG8gbG9jYXRlIEZGbXBlZyBiaW5hcmllc1xyXG4gKiAtIGFmdGVyUGFjay5qczogSGFuZGxlcyBiaW5hcnkgY29weWluZyBkdXJpbmcgcGFja2FnaW5nXHJcbiAqL1xyXG5cclxuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcclxuY29uc3QgZnMgPSByZXF1aXJlKCdmcy1leHRyYScpO1xyXG5jb25zdCB7IGFwcCB9ID0gcmVxdWlyZSgnZWxlY3Ryb24nKTtcclxuY29uc3Qgb3MgPSByZXF1aXJlKCdvcycpO1xyXG5cclxuLy8gQ2FjaGUgZm9yIHJlc29sdmVkIGJpbmFyeSBwYXRocyB0byBhdm9pZCByZXBlYXRlZCBsb29rdXBzXHJcbmNvbnN0IHBhdGhDYWNoZSA9IG5ldyBNYXAoKTtcclxuXHJcbi8qKlxyXG4gKiBSZXNvbHZlcyB0aGUgcGF0aCB0byBhIGJpbmFyeSBleGVjdXRhYmxlIHVzaW5nIG11bHRpcGxlIHJlc29sdXRpb24gc3RyYXRlZ2llc1xyXG4gKiBAcGFyYW0ge3N0cmluZ30gYmluYXJ5TmFtZSAtIE5hbWUgb2YgdGhlIGJpbmFyeSB0byByZXNvbHZlIChlLmcuLCAnZmZtcGVnJywgJ2ZmcHJvYmUnKVxyXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIEFkZGl0aW9uYWwgb3B0aW9uc1xyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMuZm9yY2VSZWZyZXNoIC0gV2hldGhlciB0byBieXBhc3MgdGhlIGNhY2hlIGFuZCBmb3JjZSBhIGZyZXNoIHJlc29sdXRpb25cclxuICogQHBhcmFtIHtzdHJpbmdbXX0gb3B0aW9ucy5jdXN0b21QYXRocyAtIEFkZGl0aW9uYWwgY3VzdG9tIHBhdGhzIHRvIGNoZWNrXHJcbiAqIEByZXR1cm5zIHtzdHJpbmd8bnVsbH0gVGhlIHJlc29sdmVkIHBhdGggdG8gdGhlIGJpbmFyeSBvciBudWxsIGlmIG5vdCBmb3VuZFxyXG4gKi9cclxuZnVuY3Rpb24gcmVzb2x2ZUJpbmFyeVBhdGgoYmluYXJ5TmFtZSwgb3B0aW9ucyA9IHt9KSB7XHJcbiAgICBjb25zdCB7IGZvcmNlUmVmcmVzaCA9IGZhbHNlLCBjdXN0b21QYXRocyA9IFtdIH0gPSBvcHRpb25zO1xyXG4gICAgXHJcbiAgICAvLyBOb3JtYWxpemUgYmluYXJ5IG5hbWUgYmFzZWQgb24gcGxhdGZvcm1cclxuICAgIGNvbnN0IG5vcm1hbGl6ZWRCaW5hcnlOYW1lID0gbm9ybWFsaXplQmluYXJ5TmFtZShiaW5hcnlOYW1lKTtcclxuICAgIGNvbnN0IGNhY2hlS2V5ID0gbm9ybWFsaXplZEJpbmFyeU5hbWU7XHJcbiAgICBcclxuICAgIC8vIFJldHVybiBjYWNoZWQgcGF0aCBpZiBhdmFpbGFibGUgYW5kIG5vdCBmb3JjaW5nIHJlZnJlc2hcclxuICAgIGlmICghZm9yY2VSZWZyZXNoICYmIHBhdGhDYWNoZS5oYXMoY2FjaGVLZXkpKSB7XHJcbiAgICAgICAgY29uc3QgY2FjaGVkUGF0aCA9IHBhdGhDYWNoZS5nZXQoY2FjaGVLZXkpO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGBbQmluYXJ5UGF0aFJlc29sdmVyXSBVc2luZyBjYWNoZWQgcGF0aCBmb3IgJHtub3JtYWxpemVkQmluYXJ5TmFtZX06ICR7Y2FjaGVkUGF0aH1gKTtcclxuICAgICAgICByZXR1cm4gY2FjaGVkUGF0aDtcclxuICAgIH1cclxuICAgIFxyXG4gICAgY29uc29sZS5sb2coYFtCaW5hcnlQYXRoUmVzb2x2ZXJdIFJlc29sdmluZyBwYXRoIGZvciBiaW5hcnk6ICR7bm9ybWFsaXplZEJpbmFyeU5hbWV9YCk7XHJcbiAgICBcclxuICAgIC8vIERldGVybWluZSBpZiB3ZSdyZSBpbiBwcm9kdWN0aW9uIGVudmlyb25tZW50XHJcbiAgICBjb25zdCBpc1Byb2R1Y3Rpb24gPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nIHx8IChhcHAgJiYgYXBwLmlzUGFja2FnZWQpO1xyXG4gICAgY29uc29sZS5sb2coYFtCaW5hcnlQYXRoUmVzb2x2ZXJdIEVudmlyb25tZW50OiAke2lzUHJvZHVjdGlvbiA/ICdQcm9kdWN0aW9uJyA6ICdEZXZlbG9wbWVudCd9YCk7XHJcbiAgICBcclxuICAgIC8vIEdldCBwbGF0Zm9ybS1zcGVjaWZpYyBwYXRocyB0byBjaGVja1xyXG4gICAgY29uc3QgcGF0aHNUb0NoZWNrID0gZ2V0UGF0aHNUb0NoZWNrKG5vcm1hbGl6ZWRCaW5hcnlOYW1lLCBpc1Byb2R1Y3Rpb24sIGN1c3RvbVBhdGhzKTtcclxuICAgIFxyXG4gICAgLy8gVHJ5IGVhY2ggcGF0aCB1bnRpbCB3ZSBmaW5kIG9uZSB0aGF0IGV4aXN0cyBhbmQgaXMgZXhlY3V0YWJsZVxyXG4gICAgZm9yIChjb25zdCBiaW5QYXRoIG9mIHBhdGhzVG9DaGVjaykge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGlmICh2ZXJpZnlCaW5hcnkoYmluUGF0aCkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbQmluYXJ5UGF0aFJlc29sdmVyXSBTdWNjZXNzZnVsbHkgcmVzb2x2ZWQgJHtub3JtYWxpemVkQmluYXJ5TmFtZX0gYXQ6ICR7YmluUGF0aH1gKTtcclxuICAgICAgICAgICAgICAgIC8vIENhY2hlIHRoZSBzdWNjZXNzZnVsIHBhdGhcclxuICAgICAgICAgICAgICAgIHBhdGhDYWNoZS5zZXQoY2FjaGVLZXksIGJpblBhdGgpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJpblBhdGg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICAvLyBKdXN0IGNvbnRpbnVlIHRvIHRoZSBuZXh0IHBhdGhcclxuICAgICAgICAgICAgY29uc29sZS5sb2coYFtCaW5hcnlQYXRoUmVzb2x2ZXJdIFBhdGggJHtiaW5QYXRofSBmYWlsZWQgdmVyaWZpY2F0aW9uOiAke2Vycm9yLm1lc3NhZ2V9YCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBJZiB3ZSBnZXQgaGVyZSwgd2UgY291bGRuJ3QgZmluZCB0aGUgYmluYXJ5XHJcbiAgICBjb25zb2xlLmVycm9yKGBbQmluYXJ5UGF0aFJlc29sdmVyXSBGYWlsZWQgdG8gcmVzb2x2ZSBwYXRoIGZvciAke25vcm1hbGl6ZWRCaW5hcnlOYW1lfWApO1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBOb3JtYWxpemVzIGJpbmFyeSBuYW1lIGJhc2VkIG9uIHBsYXRmb3JtIChhZGRzIC5leGUgZm9yIFdpbmRvd3MpXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBiaW5hcnlOYW1lIC0gTmFtZSBvZiB0aGUgYmluYXJ5XHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9IE5vcm1hbGl6ZWQgYmluYXJ5IG5hbWVcclxuICovXHJcbmZ1bmN0aW9uIG5vcm1hbGl6ZUJpbmFyeU5hbWUoYmluYXJ5TmFtZSkge1xyXG4gICAgY29uc3QgcGxhdGZvcm0gPSBvcy5wbGF0Zm9ybSgpO1xyXG4gICAgaWYgKHBsYXRmb3JtID09PSAnd2luMzInICYmICFiaW5hcnlOYW1lLmVuZHNXaXRoKCcuZXhlJykpIHtcclxuICAgICAgICByZXR1cm4gYCR7YmluYXJ5TmFtZX0uZXhlYDtcclxuICAgIH1cclxuICAgIHJldHVybiBiaW5hcnlOYW1lO1xyXG59XHJcblxyXG4vKipcclxuICogR2V0cyBhIGxpc3Qgb2YgcGF0aHMgdG8gY2hlY2sgZm9yIHRoZSBiaW5hcnkgYmFzZWQgb24gZW52aXJvbm1lbnQgYW5kIHBsYXRmb3JtXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBiaW5hcnlOYW1lIC0gTmFtZSBvZiB0aGUgYmluYXJ5XHJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNQcm9kdWN0aW9uIC0gV2hldGhlciB3ZSdyZSBpbiBwcm9kdWN0aW9uIG1vZGVcclxuICogQHBhcmFtIHtzdHJpbmdbXX0gY3VzdG9tUGF0aHMgLSBBZGRpdGlvbmFsIGN1c3RvbSBwYXRocyB0byBjaGVja1xyXG4gKiBAcmV0dXJucyB7c3RyaW5nW119IEFycmF5IG9mIHBhdGhzIHRvIGNoZWNrIGluIHByaW9yaXR5IG9yZGVyXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRQYXRoc1RvQ2hlY2soYmluYXJ5TmFtZSwgaXNQcm9kdWN0aW9uLCBjdXN0b21QYXRocyA9IFtdKSB7XHJcbiAgICBjb25zdCBwbGF0Zm9ybSA9IG9zLnBsYXRmb3JtKCk7XHJcbiAgICBjb25zdCBwYXRocyA9IFtdO1xyXG4gICAgXHJcbiAgICAvLyBBZGQgY3VzdG9tIHBhdGhzIGZpcnN0IChoaWdoZXN0IHByaW9yaXR5KVxyXG4gICAgaWYgKGN1c3RvbVBhdGhzICYmIGN1c3RvbVBhdGhzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICBwYXRocy5wdXNoKC4uLmN1c3RvbVBhdGhzKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gUHJvZHVjdGlvbiBwYXRoc1xyXG4gICAgaWYgKGlzUHJvZHVjdGlvbikge1xyXG4gICAgICAgIC8vIDEuIENoZWNrIHJlc291cmNlcyBkaXJlY3RvcnkgKGV4dHJhUmVzb3VyY2VzIGRlc3RpbmF0aW9uKVxyXG4gICAgICAgIGlmIChwcm9jZXNzLnJlc291cmNlc1BhdGgpIHtcclxuICAgICAgICAgICAgcGF0aHMucHVzaChwYXRoLmpvaW4ocHJvY2Vzcy5yZXNvdXJjZXNQYXRoLCBiaW5hcnlOYW1lKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIDIuIENoZWNrIGFwcC5hc2FyLnVucGFja2VkIHBhdGhzXHJcbiAgICAgICAgY29uc3QgYXBwUGF0aCA9IGFwcCA/IGFwcC5nZXRBcHBQYXRoKCkgOiBudWxsO1xyXG4gICAgICAgIGlmIChhcHBQYXRoKSB7XHJcbiAgICAgICAgICAgIC8vIEZvciBhc2FyLXBhY2thZ2VkIGFwcHNcclxuICAgICAgICAgICAgY29uc3QgdW5wYWNrZWQgPSBhcHBQYXRoLnJlcGxhY2UoJ2FwcC5hc2FyJywgJ2FwcC5hc2FyLnVucGFja2VkJyk7XHJcbiAgICAgICAgICAgIHBhdGhzLnB1c2gocGF0aC5qb2luKHVucGFja2VkLCAnbm9kZV9tb2R1bGVzJywgJ0BmZm1wZWctaW5zdGFsbGVyJywgJ3dpbjMyLXg2NCcsIGJpbmFyeU5hbWUpKTtcclxuICAgICAgICAgICAgcGF0aHMucHVzaChwYXRoLmpvaW4odW5wYWNrZWQsICdub2RlX21vZHVsZXMnLCAnZmZwcm9iZS1zdGF0aWMnLCAnYmluJywgcGxhdGZvcm0sICd4NjQnLCBiaW5hcnlOYW1lKSk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvLyBBbHNvIGNoZWNrIHRoZSByZWd1bGFyIGFwcCBwYXRoXHJcbiAgICAgICAgICAgIHBhdGhzLnB1c2gocGF0aC5qb2luKGFwcFBhdGgsICdub2RlX21vZHVsZXMnLCAnQGZmbXBlZy1pbnN0YWxsZXInLCAnd2luMzIteDY0JywgYmluYXJ5TmFtZSkpO1xyXG4gICAgICAgICAgICBwYXRocy5wdXNoKHBhdGguam9pbihhcHBQYXRoLCAnbm9kZV9tb2R1bGVzJywgJ2ZmcHJvYmUtc3RhdGljJywgJ2JpbicsIHBsYXRmb3JtLCAneDY0JywgYmluYXJ5TmFtZSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gRGV2ZWxvcG1lbnQgcGF0aHNcclxuICAgIGlmICghaXNQcm9kdWN0aW9uKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgLy8gRm9yIGZmbXBlZ1xyXG4gICAgICAgICAgICBpZiAoYmluYXJ5TmFtZS5pbmNsdWRlcygnZmZtcGVnJykpIHtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZmZtcGVnSW5zdGFsbGVyID0gcmVxdWlyZSgnQGZmbXBlZy1pbnN0YWxsZXIvZmZtcGVnJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgcGF0aHMucHVzaChmZm1wZWdJbnN0YWxsZXIucGF0aCk7XHJcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignW0JpbmFyeVBhdGhSZXNvbHZlcl0gRmFpbGVkIHRvIHJlcXVpcmUgQGZmbXBlZy1pbnN0YWxsZXIvZmZtcGVnJywgZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8vIEZvciBmZnByb2JlXHJcbiAgICAgICAgICAgIGlmIChiaW5hcnlOYW1lLmluY2x1ZGVzKCdmZnByb2JlJykpIHtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZmZwcm9iZVN0YXRpYyA9IHJlcXVpcmUoJ2ZmcHJvYmUtc3RhdGljJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgcGF0aHMucHVzaChmZnByb2JlU3RhdGljLnBhdGgpO1xyXG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1tCaW5hcnlQYXRoUmVzb2x2ZXJdIEZhaWxlZCB0byByZXF1aXJlIGZmcHJvYmUtc3RhdGljJywgZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8vIENoZWNrIG5vZGVfbW9kdWxlcyBkaXJlY3RseVxyXG4gICAgICAgICAgICBjb25zdCBwcm9qZWN0Um9vdCA9IHBhdGgucmVzb2x2ZShfX2Rpcm5hbWUsICcuLicsICcuLicsICcuLicpO1xyXG4gICAgICAgICAgICBwYXRocy5wdXNoKHBhdGguam9pbihwcm9qZWN0Um9vdCwgJ25vZGVfbW9kdWxlcycsICdAZmZtcGVnLWluc3RhbGxlcicsICd3aW4zMi14NjQnLCBiaW5hcnlOYW1lKSk7XHJcbiAgICAgICAgICAgIHBhdGhzLnB1c2gocGF0aC5qb2luKHByb2plY3RSb290LCAnbm9kZV9tb2R1bGVzJywgJ2ZmcHJvYmUtc3RhdGljJywgJ2JpbicsIHBsYXRmb3JtLCAneDY0JywgYmluYXJ5TmFtZSkpO1xyXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1tCaW5hcnlQYXRoUmVzb2x2ZXJdIEVycm9yIHJlc29sdmluZyBkZXZlbG9wbWVudCBwYXRoczonLCBlcnJvcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBQbGF0Zm9ybS1zcGVjaWZpYyBzeXN0ZW0gcGF0aHNcclxuICAgIGlmIChwbGF0Zm9ybSA9PT0gJ3dpbjMyJykge1xyXG4gICAgICAgIC8vIFdpbmRvd3Mgc3lzdGVtIHBhdGhzXHJcbiAgICAgICAgcGF0aHMucHVzaChwYXRoLmpvaW4ocHJvY2Vzcy5lbnYuUHJvZ3JhbUZpbGVzIHx8ICdDOlxcXFxQcm9ncmFtIEZpbGVzJywgJ2ZmbXBlZycsICdiaW4nLCBiaW5hcnlOYW1lKSk7XHJcbiAgICAgICAgcGF0aHMucHVzaChwYXRoLmpvaW4ocHJvY2Vzcy5lbnZbJ1Byb2dyYW1GaWxlcyh4ODYpJ10gfHwgJ0M6XFxcXFByb2dyYW0gRmlsZXMgKHg4NiknLCAnZmZtcGVnJywgJ2JpbicsIGJpbmFyeU5hbWUpKTtcclxuICAgIH0gZWxzZSBpZiAocGxhdGZvcm0gPT09ICdkYXJ3aW4nKSB7XHJcbiAgICAgICAgLy8gbWFjT1Mgc3lzdGVtIHBhdGhzXHJcbiAgICAgICAgcGF0aHMucHVzaChgL3Vzci9sb2NhbC9iaW4vJHtiaW5hcnlOYW1lfWApO1xyXG4gICAgICAgIHBhdGhzLnB1c2goYC9vcHQvaG9tZWJyZXcvYmluLyR7YmluYXJ5TmFtZX1gKTtcclxuICAgICAgICBwYXRocy5wdXNoKGAvb3B0L2xvY2FsL2Jpbi8ke2JpbmFyeU5hbWV9YCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIExpbnV4IHN5c3RlbSBwYXRoc1xyXG4gICAgICAgIHBhdGhzLnB1c2goYC91c3IvYmluLyR7YmluYXJ5TmFtZX1gKTtcclxuICAgICAgICBwYXRocy5wdXNoKGAvdXNyL2xvY2FsL2Jpbi8ke2JpbmFyeU5hbWV9YCk7XHJcbiAgICAgICAgcGF0aHMucHVzaChgL29wdC9iaW4vJHtiaW5hcnlOYW1lfWApO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBMb2cgYWxsIHBhdGhzIHdlJ3JlIGdvaW5nIHRvIGNoZWNrXHJcbiAgICBjb25zb2xlLmxvZyhgW0JpbmFyeVBhdGhSZXNvbHZlcl0gUGF0aHMgdG8gY2hlY2sgZm9yICR7YmluYXJ5TmFtZX06YCwgcGF0aHMpO1xyXG4gICAgXHJcbiAgICByZXR1cm4gcGF0aHM7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBWZXJpZmllcyB0aGF0IGEgYmluYXJ5IGV4aXN0cyBhbmQgaXMgZXhlY3V0YWJsZVxyXG4gKiBAcGFyYW0ge3N0cmluZ30gYmluYXJ5UGF0aCAtIFBhdGggdG8gdGhlIGJpbmFyeVxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgYmluYXJ5IGV4aXN0cyBhbmQgaXMgZXhlY3V0YWJsZVxyXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIGJpbmFyeSBkb2Vzbid0IGV4aXN0IG9yIGlzbid0IGV4ZWN1dGFibGVcclxuICovXHJcbmZ1bmN0aW9uIHZlcmlmeUJpbmFyeShiaW5hcnlQYXRoKSB7XHJcbiAgICBpZiAoIWJpbmFyeVBhdGgpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0JpbmFyeSBwYXRoIGlzIGVtcHR5IG9yIHVuZGVmaW5lZCcpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICB0cnkge1xyXG4gICAgICAgIC8vIENoZWNrIGlmIGZpbGUgZXhpc3RzXHJcbiAgICAgICAgaWYgKCFmcy5leGlzdHNTeW5jKGJpbmFyeVBhdGgpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQmluYXJ5IGRvZXMgbm90IGV4aXN0IGF0IHBhdGg6ICR7YmluYXJ5UGF0aH1gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gR2V0IGZpbGUgc3RhdHNcclxuICAgICAgICBjb25zdCBzdGF0cyA9IGZzLnN0YXRTeW5jKGJpbmFyeVBhdGgpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIENoZWNrIGlmIGl0J3MgYSBmaWxlIChub3QgYSBkaXJlY3RvcnkpXHJcbiAgICAgICAgaWYgKCFzdGF0cy5pc0ZpbGUoKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFBhdGggZXhpc3RzIGJ1dCBpcyBub3QgYSBmaWxlOiAke2JpbmFyeVBhdGh9YCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIE9uIFVuaXgtbGlrZSBzeXN0ZW1zLCBjaGVjayBpZiB0aGUgZmlsZSBpcyBleGVjdXRhYmxlXHJcbiAgICAgICAgY29uc3QgcGxhdGZvcm0gPSBvcy5wbGF0Zm9ybSgpO1xyXG4gICAgICAgIGlmIChwbGF0Zm9ybSAhPT0gJ3dpbjMyJykge1xyXG4gICAgICAgICAgICAvLyBDaGVjayBpZiBmaWxlIGhhcyBleGVjdXRlIHBlcm1pc3Npb24gKFVuaXgtbGlrZSBzeXN0ZW1zKVxyXG4gICAgICAgICAgICBjb25zdCBpc0V4ZWN1dGFibGUgPSAhIShzdGF0cy5tb2RlICYgMG8xMTEpOyAvLyBDaGVjayBpZiBhbnkgZXhlY3V0ZSBiaXQgaXMgc2V0XHJcbiAgICAgICAgICAgIGlmICghaXNFeGVjdXRhYmxlKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEJpbmFyeSBleGlzdHMgYnV0IGlzIG5vdCBleGVjdXRhYmxlOiAke2JpbmFyeVBhdGh9YCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gTG9nIGZpbGUgZGV0YWlscyBmb3IgZGVidWdnaW5nXHJcbiAgICAgICAgY29uc29sZS5sb2coYFtCaW5hcnlQYXRoUmVzb2x2ZXJdIFZlcmlmaWVkIGJpbmFyeSBhdCAke2JpbmFyeVBhdGh9YCk7XHJcbiAgICAgICAgY29uc29sZS5sb2coYFtCaW5hcnlQYXRoUmVzb2x2ZXJdIEZpbGUgc2l6ZTogJHtzdGF0cy5zaXplfSBieXRlc2ApO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGBbQmluYXJ5UGF0aFJlc29sdmVyXSBGaWxlIHBlcm1pc3Npb25zOiAke3N0YXRzLm1vZGUudG9TdHJpbmcoOCl9YCk7XHJcbiAgICAgICAgY29uc29sZS5sb2coYFtCaW5hcnlQYXRoUmVzb2x2ZXJdIExhc3QgbW9kaWZpZWQ6ICR7c3RhdHMubXRpbWV9YCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQmluYXJ5IHZlcmlmaWNhdGlvbiBmYWlsZWQ6ICR7ZXJyb3IubWVzc2FnZX1gKTtcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIENsZWFycyB0aGUgcGF0aCBjYWNoZVxyXG4gKi9cclxuZnVuY3Rpb24gY2xlYXJQYXRoQ2FjaGUoKSB7XHJcbiAgICBwYXRoQ2FjaGUuY2xlYXIoKTtcclxuICAgIGNvbnNvbGUubG9nKCdbQmluYXJ5UGF0aFJlc29sdmVyXSBQYXRoIGNhY2hlIGNsZWFyZWQnKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdldHMgdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIHBhdGggY2FjaGVcclxuICogQHJldHVybnMge09iamVjdH0gT2JqZWN0IHdpdGggYmluYXJ5IG5hbWVzIGFzIGtleXMgYW5kIHJlc29sdmVkIHBhdGhzIGFzIHZhbHVlc1xyXG4gKi9cclxuZnVuY3Rpb24gZ2V0UGF0aENhY2hlKCkge1xyXG4gICAgY29uc3QgY2FjaGUgPSB7fTtcclxuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHBhdGhDYWNoZS5lbnRyaWVzKCkpIHtcclxuICAgICAgICBjYWNoZVtrZXldID0gdmFsdWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY2FjaGU7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG4gICAgcmVzb2x2ZUJpbmFyeVBhdGgsXHJcbiAgICB2ZXJpZnlCaW5hcnksXHJcbiAgICBjbGVhclBhdGhDYWNoZSxcclxuICAgIGdldFBhdGhDYWNoZVxyXG59OyJdLCJtYXBwaW5ncyI6Ijs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE1BQU1BLElBQUksR0FBR0MsT0FBTyxDQUFDLE1BQU0sQ0FBQztBQUM1QixNQUFNQyxFQUFFLEdBQUdELE9BQU8sQ0FBQyxVQUFVLENBQUM7QUFDOUIsTUFBTTtFQUFFRTtBQUFJLENBQUMsR0FBR0YsT0FBTyxDQUFDLFVBQVUsQ0FBQztBQUNuQyxNQUFNRyxFQUFFLEdBQUdILE9BQU8sQ0FBQyxJQUFJLENBQUM7O0FBRXhCO0FBQ0EsTUFBTUksU0FBUyxHQUFHLElBQUlDLEdBQUcsQ0FBQyxDQUFDOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBU0MsaUJBQWlCQSxDQUFDQyxVQUFVLEVBQUVDLE9BQU8sR0FBRyxDQUFDLENBQUMsRUFBRTtFQUNqRCxNQUFNO0lBQUVDLFlBQVksR0FBRyxLQUFLO0lBQUVDLFdBQVcsR0FBRztFQUFHLENBQUMsR0FBR0YsT0FBTzs7RUFFMUQ7RUFDQSxNQUFNRyxvQkFBb0IsR0FBR0MsbUJBQW1CLENBQUNMLFVBQVUsQ0FBQztFQUM1RCxNQUFNTSxRQUFRLEdBQUdGLG9CQUFvQjs7RUFFckM7RUFDQSxJQUFJLENBQUNGLFlBQVksSUFBSUwsU0FBUyxDQUFDVSxHQUFHLENBQUNELFFBQVEsQ0FBQyxFQUFFO0lBQzFDLE1BQU1FLFVBQVUsR0FBR1gsU0FBUyxDQUFDWSxHQUFHLENBQUNILFFBQVEsQ0FBQztJQUMxQ0ksT0FBTyxDQUFDQyxHQUFHLENBQUMsOENBQThDUCxvQkFBb0IsS0FBS0ksVUFBVSxFQUFFLENBQUM7SUFDaEcsT0FBT0EsVUFBVTtFQUNyQjtFQUVBRSxPQUFPLENBQUNDLEdBQUcsQ0FBQyxtREFBbURQLG9CQUFvQixFQUFFLENBQUM7O0VBRXRGO0VBQ0EsTUFBTVEsWUFBWSxHQUFHQyxPQUFPLENBQUNDLEdBQUcsQ0FBQ0MsUUFBUSxLQUFLLFlBQVksSUFBS3BCLEdBQUcsSUFBSUEsR0FBRyxDQUFDcUIsVUFBVztFQUNyRk4sT0FBTyxDQUFDQyxHQUFHLENBQUMscUNBQXFDQyxZQUFZLEdBQUcsWUFBWSxHQUFHLGFBQWEsRUFBRSxDQUFDOztFQUUvRjtFQUNBLE1BQU1LLFlBQVksR0FBR0MsZUFBZSxDQUFDZCxvQkFBb0IsRUFBRVEsWUFBWSxFQUFFVCxXQUFXLENBQUM7O0VBRXJGO0VBQ0EsS0FBSyxNQUFNZ0IsT0FBTyxJQUFJRixZQUFZLEVBQUU7SUFDaEMsSUFBSTtNQUNBLElBQUlHLFlBQVksQ0FBQ0QsT0FBTyxDQUFDLEVBQUU7UUFDdkJULE9BQU8sQ0FBQ0MsR0FBRyxDQUFDLDhDQUE4Q1Asb0JBQW9CLFFBQVFlLE9BQU8sRUFBRSxDQUFDO1FBQ2hHO1FBQ0F0QixTQUFTLENBQUN3QixHQUFHLENBQUNmLFFBQVEsRUFBRWEsT0FBTyxDQUFDO1FBQ2hDLE9BQU9BLE9BQU87TUFDbEI7SUFDSixDQUFDLENBQUMsT0FBT0csS0FBSyxFQUFFO01BQ1o7TUFDQVosT0FBTyxDQUFDQyxHQUFHLENBQUMsNkJBQTZCUSxPQUFPLHlCQUF5QkcsS0FBSyxDQUFDQyxPQUFPLEVBQUUsQ0FBQztJQUM3RjtFQUNKOztFQUVBO0VBQ0FiLE9BQU8sQ0FBQ1ksS0FBSyxDQUFDLG1EQUFtRGxCLG9CQUFvQixFQUFFLENBQUM7RUFDeEYsT0FBTyxJQUFJO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVNDLG1CQUFtQkEsQ0FBQ0wsVUFBVSxFQUFFO0VBQ3JDLE1BQU13QixRQUFRLEdBQUc1QixFQUFFLENBQUM0QixRQUFRLENBQUMsQ0FBQztFQUM5QixJQUFJQSxRQUFRLEtBQUssT0FBTyxJQUFJLENBQUN4QixVQUFVLENBQUN5QixRQUFRLENBQUMsTUFBTSxDQUFDLEVBQUU7SUFDdEQsT0FBTyxHQUFHekIsVUFBVSxNQUFNO0VBQzlCO0VBQ0EsT0FBT0EsVUFBVTtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVNrQixlQUFlQSxDQUFDbEIsVUFBVSxFQUFFWSxZQUFZLEVBQUVULFdBQVcsR0FBRyxFQUFFLEVBQUU7RUFDakUsTUFBTXFCLFFBQVEsR0FBRzVCLEVBQUUsQ0FBQzRCLFFBQVEsQ0FBQyxDQUFDO0VBQzlCLE1BQU1FLEtBQUssR0FBRyxFQUFFOztFQUVoQjtFQUNBLElBQUl2QixXQUFXLElBQUlBLFdBQVcsQ0FBQ3dCLE1BQU0sR0FBRyxDQUFDLEVBQUU7SUFDdkNELEtBQUssQ0FBQ0UsSUFBSSxDQUFDLEdBQUd6QixXQUFXLENBQUM7RUFDOUI7O0VBRUE7RUFDQSxJQUFJUyxZQUFZLEVBQUU7SUFDZDtJQUNBLElBQUlDLE9BQU8sQ0FBQ2dCLGFBQWEsRUFBRTtNQUN2QkgsS0FBSyxDQUFDRSxJQUFJLENBQUNwQyxJQUFJLENBQUNzQyxJQUFJLENBQUNqQixPQUFPLENBQUNnQixhQUFhLEVBQUU3QixVQUFVLENBQUMsQ0FBQztJQUM1RDs7SUFFQTtJQUNBLE1BQU0rQixPQUFPLEdBQUdwQyxHQUFHLEdBQUdBLEdBQUcsQ0FBQ3FDLFVBQVUsQ0FBQyxDQUFDLEdBQUcsSUFBSTtJQUM3QyxJQUFJRCxPQUFPLEVBQUU7TUFDVDtNQUNBLE1BQU1FLFFBQVEsR0FBR0YsT0FBTyxDQUFDRyxPQUFPLENBQUMsVUFBVSxFQUFFLG1CQUFtQixDQUFDO01BQ2pFUixLQUFLLENBQUNFLElBQUksQ0FBQ3BDLElBQUksQ0FBQ3NDLElBQUksQ0FBQ0csUUFBUSxFQUFFLGNBQWMsRUFBRSxtQkFBbUIsRUFBRSxXQUFXLEVBQUVqQyxVQUFVLENBQUMsQ0FBQztNQUM3RjBCLEtBQUssQ0FBQ0UsSUFBSSxDQUFDcEMsSUFBSSxDQUFDc0MsSUFBSSxDQUFDRyxRQUFRLEVBQUUsY0FBYyxFQUFFLGdCQUFnQixFQUFFLEtBQUssRUFBRVQsUUFBUSxFQUFFLEtBQUssRUFBRXhCLFVBQVUsQ0FBQyxDQUFDOztNQUVyRztNQUNBMEIsS0FBSyxDQUFDRSxJQUFJLENBQUNwQyxJQUFJLENBQUNzQyxJQUFJLENBQUNDLE9BQU8sRUFBRSxjQUFjLEVBQUUsbUJBQW1CLEVBQUUsV0FBVyxFQUFFL0IsVUFBVSxDQUFDLENBQUM7TUFDNUYwQixLQUFLLENBQUNFLElBQUksQ0FBQ3BDLElBQUksQ0FBQ3NDLElBQUksQ0FBQ0MsT0FBTyxFQUFFLGNBQWMsRUFBRSxnQkFBZ0IsRUFBRSxLQUFLLEVBQUVQLFFBQVEsRUFBRSxLQUFLLEVBQUV4QixVQUFVLENBQUMsQ0FBQztJQUN4RztFQUNKOztFQUVBO0VBQ0EsSUFBSSxDQUFDWSxZQUFZLEVBQUU7SUFDZixJQUFJO01BQ0E7TUFDQSxJQUFJWixVQUFVLENBQUNtQyxRQUFRLENBQUMsUUFBUSxDQUFDLEVBQUU7UUFDL0IsSUFBSTtVQUNBLE1BQU1DLGVBQWUsR0FBRzNDLE9BQU8sQ0FBQywwQkFBMEIsQ0FBQztVQUMzRGlDLEtBQUssQ0FBQ0UsSUFBSSxDQUFDUSxlQUFlLENBQUM1QyxJQUFJLENBQUM7UUFDcEMsQ0FBQyxDQUFDLE9BQU82QyxDQUFDLEVBQUU7VUFDUjNCLE9BQU8sQ0FBQ1ksS0FBSyxDQUFDLGlFQUFpRSxFQUFFZSxDQUFDLENBQUM7UUFDdkY7TUFDSjs7TUFFQTtNQUNBLElBQUlyQyxVQUFVLENBQUNtQyxRQUFRLENBQUMsU0FBUyxDQUFDLEVBQUU7UUFDaEMsSUFBSTtVQUNBLE1BQU1HLGFBQWEsR0FBRzdDLE9BQU8sQ0FBQyxnQkFBZ0IsQ0FBQztVQUMvQ2lDLEtBQUssQ0FBQ0UsSUFBSSxDQUFDVSxhQUFhLENBQUM5QyxJQUFJLENBQUM7UUFDbEMsQ0FBQyxDQUFDLE9BQU82QyxDQUFDLEVBQUU7VUFDUjNCLE9BQU8sQ0FBQ1ksS0FBSyxDQUFDLHVEQUF1RCxFQUFFZSxDQUFDLENBQUM7UUFDN0U7TUFDSjs7TUFFQTtNQUNBLE1BQU1FLFdBQVcsR0FBRy9DLElBQUksQ0FBQ2dELE9BQU8sQ0FBQ0MsU0FBUyxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxDQUFDO01BQzdEZixLQUFLLENBQUNFLElBQUksQ0FBQ3BDLElBQUksQ0FBQ3NDLElBQUksQ0FBQ1MsV0FBVyxFQUFFLGNBQWMsRUFBRSxtQkFBbUIsRUFBRSxXQUFXLEVBQUV2QyxVQUFVLENBQUMsQ0FBQztNQUNoRzBCLEtBQUssQ0FBQ0UsSUFBSSxDQUFDcEMsSUFBSSxDQUFDc0MsSUFBSSxDQUFDUyxXQUFXLEVBQUUsY0FBYyxFQUFFLGdCQUFnQixFQUFFLEtBQUssRUFBRWYsUUFBUSxFQUFFLEtBQUssRUFBRXhCLFVBQVUsQ0FBQyxDQUFDO0lBQzVHLENBQUMsQ0FBQyxPQUFPc0IsS0FBSyxFQUFFO01BQ1paLE9BQU8sQ0FBQ1ksS0FBSyxDQUFDLHlEQUF5RCxFQUFFQSxLQUFLLENBQUM7SUFDbkY7RUFDSjs7RUFFQTtFQUNBLElBQUlFLFFBQVEsS0FBSyxPQUFPLEVBQUU7SUFDdEI7SUFDQUUsS0FBSyxDQUFDRSxJQUFJLENBQUNwQyxJQUFJLENBQUNzQyxJQUFJLENBQUNqQixPQUFPLENBQUNDLEdBQUcsQ0FBQzRCLFlBQVksSUFBSSxtQkFBbUIsRUFBRSxRQUFRLEVBQUUsS0FBSyxFQUFFMUMsVUFBVSxDQUFDLENBQUM7SUFDbkcwQixLQUFLLENBQUNFLElBQUksQ0FBQ3BDLElBQUksQ0FBQ3NDLElBQUksQ0FBQ2pCLE9BQU8sQ0FBQ0MsR0FBRyxDQUFDLG1CQUFtQixDQUFDLElBQUkseUJBQXlCLEVBQUUsUUFBUSxFQUFFLEtBQUssRUFBRWQsVUFBVSxDQUFDLENBQUM7RUFDckgsQ0FBQyxNQUFNLElBQUl3QixRQUFRLEtBQUssUUFBUSxFQUFFO0lBQzlCO0lBQ0FFLEtBQUssQ0FBQ0UsSUFBSSxDQUFDLGtCQUFrQjVCLFVBQVUsRUFBRSxDQUFDO0lBQzFDMEIsS0FBSyxDQUFDRSxJQUFJLENBQUMscUJBQXFCNUIsVUFBVSxFQUFFLENBQUM7SUFDN0MwQixLQUFLLENBQUNFLElBQUksQ0FBQyxrQkFBa0I1QixVQUFVLEVBQUUsQ0FBQztFQUM5QyxDQUFDLE1BQU07SUFDSDtJQUNBMEIsS0FBSyxDQUFDRSxJQUFJLENBQUMsWUFBWTVCLFVBQVUsRUFBRSxDQUFDO0lBQ3BDMEIsS0FBSyxDQUFDRSxJQUFJLENBQUMsa0JBQWtCNUIsVUFBVSxFQUFFLENBQUM7SUFDMUMwQixLQUFLLENBQUNFLElBQUksQ0FBQyxZQUFZNUIsVUFBVSxFQUFFLENBQUM7RUFDeEM7O0VBRUE7RUFDQVUsT0FBTyxDQUFDQyxHQUFHLENBQUMsMkNBQTJDWCxVQUFVLEdBQUcsRUFBRTBCLEtBQUssQ0FBQztFQUU1RSxPQUFPQSxLQUFLO0FBQ2hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVNOLFlBQVlBLENBQUN1QixVQUFVLEVBQUU7RUFDOUIsSUFBSSxDQUFDQSxVQUFVLEVBQUU7SUFDYixNQUFNLElBQUlDLEtBQUssQ0FBQyxtQ0FBbUMsQ0FBQztFQUN4RDtFQUVBLElBQUk7SUFDQTtJQUNBLElBQUksQ0FBQ2xELEVBQUUsQ0FBQ21ELFVBQVUsQ0FBQ0YsVUFBVSxDQUFDLEVBQUU7TUFDNUIsTUFBTSxJQUFJQyxLQUFLLENBQUMsa0NBQWtDRCxVQUFVLEVBQUUsQ0FBQztJQUNuRTs7SUFFQTtJQUNBLE1BQU1HLEtBQUssR0FBR3BELEVBQUUsQ0FBQ3FELFFBQVEsQ0FBQ0osVUFBVSxDQUFDOztJQUVyQztJQUNBLElBQUksQ0FBQ0csS0FBSyxDQUFDRSxNQUFNLENBQUMsQ0FBQyxFQUFFO01BQ2pCLE1BQU0sSUFBSUosS0FBSyxDQUFDLGtDQUFrQ0QsVUFBVSxFQUFFLENBQUM7SUFDbkU7O0lBRUE7SUFDQSxNQUFNbkIsUUFBUSxHQUFHNUIsRUFBRSxDQUFDNEIsUUFBUSxDQUFDLENBQUM7SUFDOUIsSUFBSUEsUUFBUSxLQUFLLE9BQU8sRUFBRTtNQUN0QjtNQUNBLE1BQU15QixZQUFZLEdBQUcsQ0FBQyxFQUFFSCxLQUFLLENBQUNJLElBQUksR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDO01BQzdDLElBQUksQ0FBQ0QsWUFBWSxFQUFFO1FBQ2YsTUFBTSxJQUFJTCxLQUFLLENBQUMsd0NBQXdDRCxVQUFVLEVBQUUsQ0FBQztNQUN6RTtJQUNKOztJQUVBO0lBQ0FqQyxPQUFPLENBQUNDLEdBQUcsQ0FBQywyQ0FBMkNnQyxVQUFVLEVBQUUsQ0FBQztJQUNwRWpDLE9BQU8sQ0FBQ0MsR0FBRyxDQUFDLG1DQUFtQ21DLEtBQUssQ0FBQ0ssSUFBSSxRQUFRLENBQUM7SUFDbEV6QyxPQUFPLENBQUNDLEdBQUcsQ0FBQywwQ0FBMENtQyxLQUFLLENBQUNJLElBQUksQ0FBQ0UsUUFBUSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUM7SUFDL0UxQyxPQUFPLENBQUNDLEdBQUcsQ0FBQyx1Q0FBdUNtQyxLQUFLLENBQUNPLEtBQUssRUFBRSxDQUFDO0lBRWpFLE9BQU8sSUFBSTtFQUNmLENBQUMsQ0FBQyxPQUFPL0IsS0FBSyxFQUFFO0lBQ1osTUFBTSxJQUFJc0IsS0FBSyxDQUFDLCtCQUErQnRCLEtBQUssQ0FBQ0MsT0FBTyxFQUFFLENBQUM7RUFDbkU7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTK0IsY0FBY0EsQ0FBQSxFQUFHO0VBQ3RCekQsU0FBUyxDQUFDMEQsS0FBSyxDQUFDLENBQUM7RUFDakI3QyxPQUFPLENBQUNDLEdBQUcsQ0FBQyx5Q0FBeUMsQ0FBQztBQUMxRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM2QyxZQUFZQSxDQUFBLEVBQUc7RUFDcEIsTUFBTUMsS0FBSyxHQUFHLENBQUMsQ0FBQztFQUNoQixLQUFLLE1BQU0sQ0FBQ0MsR0FBRyxFQUFFQyxLQUFLLENBQUMsSUFBSTlELFNBQVMsQ0FBQytELE9BQU8sQ0FBQyxDQUFDLEVBQUU7SUFDNUNILEtBQUssQ0FBQ0MsR0FBRyxDQUFDLEdBQUdDLEtBQUs7RUFDdEI7RUFDQSxPQUFPRixLQUFLO0FBQ2hCO0FBRUFJLE1BQU0sQ0FBQ0MsT0FBTyxHQUFHO0VBQ2IvRCxpQkFBaUI7RUFDakJxQixZQUFZO0VBQ1prQyxjQUFjO0VBQ2RFO0FBQ0osQ0FBQyIsImlnbm9yZUxpc3QiOltdfQ==