"use strict";

/**
 * BinaryPathResolver.js
 * 
 * Utility module for reliably locating FFmpeg and other binaries in both development
 * and production environments. This module helps fix the "Conversion produced empty content"
 * error in video processing by ensuring binaries are correctly located regardless of
 * environment or platform.
 * 
 * Features:
 * - Multiple resolution strategies with fallbacks
 * - Cross-platform path handling (Windows, macOS, Linux)
 * - Caching mechanism to optimize repeated lookups
 * - Binary verification to confirm existence and executability
 * - Detailed logging for troubleshooting
 * 
 * Related Files:
 * - VideoConverter.js: Uses this module to locate FFmpeg binaries
 * - AudioConverter.js: Uses this module to locate FFmpeg binaries
 * - afterPack.js: Handles binary copying during packaging
 */

const path = require('path');
const fs = require('fs-extra');
const {
  app
} = require('electron');
const os = require('os');

// Cache for resolved binary paths to avoid repeated lookups
const pathCache = new Map();

/**
 * Resolves the path to a binary executable using multiple resolution strategies
 * @param {string} binaryName - Name of the binary to resolve (e.g., 'ffmpeg', 'ffprobe')
 * @param {Object} options - Additional options
 * @param {boolean} options.forceRefresh - Whether to bypass the cache and force a fresh resolution
 * @param {string[]} options.customPaths - Additional custom paths to check
 * @returns {string|null} The resolved path to the binary or null if not found
 */
function resolveBinaryPath(binaryName, options = {}) {
  const {
    forceRefresh = false,
    customPaths = []
  } = options;

  // Normalize binary name based on platform
  const normalizedBinaryName = normalizeBinaryName(binaryName);
  const cacheKey = normalizedBinaryName;

  // Return cached path if available and not forcing refresh
  if (!forceRefresh && pathCache.has(cacheKey)) {
    const cachedPath = pathCache.get(cacheKey);
    console.log(`[BinaryPathResolver] Using cached path for ${normalizedBinaryName}: ${cachedPath}`);
    return cachedPath;
  }
  console.log(`[BinaryPathResolver] Resolving path for binary: ${normalizedBinaryName}`);

  // Determine if we're in production environment
  const isProduction = process.env.NODE_ENV === 'production' || app && app.isPackaged;
  console.log(`[BinaryPathResolver] Environment: ${isProduction ? 'Production' : 'Development'}`);

  // Get platform-specific paths to check
  const pathsToCheck = getPathsToCheck(normalizedBinaryName, isProduction, customPaths);

  // Try each path until we find one that exists and is executable
  for (const binPath of pathsToCheck) {
    try {
      if (verifyBinary(binPath)) {
        console.log(`[BinaryPathResolver] Successfully resolved ${normalizedBinaryName} at: ${binPath}`);
        // Cache the successful path
        pathCache.set(cacheKey, binPath);
        return binPath;
      }
    } catch (error) {
      // Just continue to the next path
      console.log(`[BinaryPathResolver] Path ${binPath} failed verification: ${error.message}`);
    }
  }

  // If we get here, we couldn't find the binary
  console.error(`[BinaryPathResolver] Failed to resolve path for ${normalizedBinaryName}`);
  return null;
}

/**
 * Normalizes binary name based on platform (adds .exe for Windows)
 * @param {string} binaryName - Name of the binary
 * @returns {string} Normalized binary name
 */
function normalizeBinaryName(binaryName) {
  const platform = os.platform();
  if (platform === 'win32' && !binaryName.endsWith('.exe')) {
    return `${binaryName}.exe`;
  }
  return binaryName;
}

/**
 * Gets a list of paths to check for the binary based on environment and platform
 * @param {string} binaryName - Name of the binary
 * @param {boolean} isProduction - Whether we're in production mode
 * @param {string[]} customPaths - Additional custom paths to check
 * @returns {string[]} Array of paths to check in priority order
 */
function getPathsToCheck(binaryName, isProduction, customPaths = []) {
  const platform = os.platform();
  const paths = [];

  // Add custom paths first (highest priority)
  if (customPaths && customPaths.length > 0) {
    paths.push(...customPaths);
  }

  // Production paths - FFmpeg and FFprobe are no longer required
  if (isProduction) {
    console.log('[BinaryPathResolver] FFmpeg and FFprobe binaries are no longer required in production');
  }

  // Development paths
  if (!isProduction) {
    try {
      // FFmpeg and FFprobe are no longer required for the application
      console.log('[BinaryPathResolver] FFmpeg and FFprobe are no longer required');

      // FFmpeg and FFprobe paths are no longer needed
    } catch (error) {
      console.error('[BinaryPathResolver] Error resolving development paths:', error);
    }
  }

  // No system paths needed as FFmpeg and FFprobe are no longer required

  // Log all paths we're going to check
  console.log(`[BinaryPathResolver] Paths to check for ${binaryName}:`, paths);
  return paths;
}

/**
 * Verifies that a binary exists and is executable
 * @param {string} binaryPath - Path to the binary
 * @returns {boolean} True if the binary exists and is executable
 * @throws {Error} If the binary doesn't exist or isn't executable
 */
function verifyBinary(binaryPath) {
  if (!binaryPath) {
    throw new Error('Binary path is empty or undefined');
  }
  try {
    // Check if file exists
    if (!fs.existsSync(binaryPath)) {
      throw new Error(`Binary does not exist at path: ${binaryPath}`);
    }

    // Get file stats
    const stats = fs.statSync(binaryPath);

    // Check if it's a file (not a directory)
    if (!stats.isFile()) {
      throw new Error(`Path exists but is not a file: ${binaryPath}`);
    }

    // On Unix-like systems, check if the file is executable
    const platform = os.platform();
    if (platform !== 'win32') {
      // Check if file has execute permission (Unix-like systems)
      const isExecutable = !!(stats.mode & 0o111); // Check if any execute bit is set
      if (!isExecutable) {
        throw new Error(`Binary exists but is not executable: ${binaryPath}`);
      }
    }

    // Log file details for debugging
    console.log(`[BinaryPathResolver] Verified binary at ${binaryPath}`);
    console.log(`[BinaryPathResolver] File size: ${stats.size} bytes`);
    console.log(`[BinaryPathResolver] File permissions: ${stats.mode.toString(8)}`);
    console.log(`[BinaryPathResolver] Last modified: ${stats.mtime}`);
    return true;
  } catch (error) {
    throw new Error(`Binary verification failed: ${error.message}`);
  }
}

/**
 * Clears the path cache
 */
function clearPathCache() {
  pathCache.clear();
  console.log('[BinaryPathResolver] Path cache cleared');
}

/**
 * Gets the current state of the path cache
 * @returns {Object} Object with binary names as keys and resolved paths as values
 */
function getPathCache() {
  const cache = {};
  for (const [key, value] of pathCache.entries()) {
    cache[key] = value;
  }
  return cache;
}
module.exports = {
  resolveBinaryPath,
  verifyBinary,
  clearPathCache,
  getPathCache
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJwYXRoIiwicmVxdWlyZSIsImZzIiwiYXBwIiwib3MiLCJwYXRoQ2FjaGUiLCJNYXAiLCJyZXNvbHZlQmluYXJ5UGF0aCIsImJpbmFyeU5hbWUiLCJvcHRpb25zIiwiZm9yY2VSZWZyZXNoIiwiY3VzdG9tUGF0aHMiLCJub3JtYWxpemVkQmluYXJ5TmFtZSIsIm5vcm1hbGl6ZUJpbmFyeU5hbWUiLCJjYWNoZUtleSIsImhhcyIsImNhY2hlZFBhdGgiLCJnZXQiLCJjb25zb2xlIiwibG9nIiwiaXNQcm9kdWN0aW9uIiwicHJvY2VzcyIsImVudiIsIk5PREVfRU5WIiwiaXNQYWNrYWdlZCIsInBhdGhzVG9DaGVjayIsImdldFBhdGhzVG9DaGVjayIsImJpblBhdGgiLCJ2ZXJpZnlCaW5hcnkiLCJzZXQiLCJlcnJvciIsIm1lc3NhZ2UiLCJwbGF0Zm9ybSIsImVuZHNXaXRoIiwicGF0aHMiLCJsZW5ndGgiLCJwdXNoIiwiYmluYXJ5UGF0aCIsIkVycm9yIiwiZXhpc3RzU3luYyIsInN0YXRzIiwic3RhdFN5bmMiLCJpc0ZpbGUiLCJpc0V4ZWN1dGFibGUiLCJtb2RlIiwic2l6ZSIsInRvU3RyaW5nIiwibXRpbWUiLCJjbGVhclBhdGhDYWNoZSIsImNsZWFyIiwiZ2V0UGF0aENhY2hlIiwiY2FjaGUiLCJrZXkiLCJ2YWx1ZSIsImVudHJpZXMiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2VsZWN0cm9uL3V0aWxzL0JpbmFyeVBhdGhSZXNvbHZlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogQmluYXJ5UGF0aFJlc29sdmVyLmpzXHJcbiAqIFxyXG4gKiBVdGlsaXR5IG1vZHVsZSBmb3IgcmVsaWFibHkgbG9jYXRpbmcgRkZtcGVnIGFuZCBvdGhlciBiaW5hcmllcyBpbiBib3RoIGRldmVsb3BtZW50XHJcbiAqIGFuZCBwcm9kdWN0aW9uIGVudmlyb25tZW50cy4gVGhpcyBtb2R1bGUgaGVscHMgZml4IHRoZSBcIkNvbnZlcnNpb24gcHJvZHVjZWQgZW1wdHkgY29udGVudFwiXHJcbiAqIGVycm9yIGluIHZpZGVvIHByb2Nlc3NpbmcgYnkgZW5zdXJpbmcgYmluYXJpZXMgYXJlIGNvcnJlY3RseSBsb2NhdGVkIHJlZ2FyZGxlc3Mgb2ZcclxuICogZW52aXJvbm1lbnQgb3IgcGxhdGZvcm0uXHJcbiAqIFxyXG4gKiBGZWF0dXJlczpcclxuICogLSBNdWx0aXBsZSByZXNvbHV0aW9uIHN0cmF0ZWdpZXMgd2l0aCBmYWxsYmFja3NcclxuICogLSBDcm9zcy1wbGF0Zm9ybSBwYXRoIGhhbmRsaW5nIChXaW5kb3dzLCBtYWNPUywgTGludXgpXHJcbiAqIC0gQ2FjaGluZyBtZWNoYW5pc20gdG8gb3B0aW1pemUgcmVwZWF0ZWQgbG9va3Vwc1xyXG4gKiAtIEJpbmFyeSB2ZXJpZmljYXRpb24gdG8gY29uZmlybSBleGlzdGVuY2UgYW5kIGV4ZWN1dGFiaWxpdHlcclxuICogLSBEZXRhaWxlZCBsb2dnaW5nIGZvciB0cm91Ymxlc2hvb3RpbmdcclxuICogXHJcbiAqIFJlbGF0ZWQgRmlsZXM6XHJcbiAqIC0gVmlkZW9Db252ZXJ0ZXIuanM6IFVzZXMgdGhpcyBtb2R1bGUgdG8gbG9jYXRlIEZGbXBlZyBiaW5hcmllc1xyXG4gKiAtIEF1ZGlvQ29udmVydGVyLmpzOiBVc2VzIHRoaXMgbW9kdWxlIHRvIGxvY2F0ZSBGRm1wZWcgYmluYXJpZXNcclxuICogLSBhZnRlclBhY2suanM6IEhhbmRsZXMgYmluYXJ5IGNvcHlpbmcgZHVyaW5nIHBhY2thZ2luZ1xyXG4gKi9cclxuXHJcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XHJcbmNvbnN0IGZzID0gcmVxdWlyZSgnZnMtZXh0cmEnKTtcclxuY29uc3QgeyBhcHAgfSA9IHJlcXVpcmUoJ2VsZWN0cm9uJyk7XHJcbmNvbnN0IG9zID0gcmVxdWlyZSgnb3MnKTtcclxuXHJcbi8vIENhY2hlIGZvciByZXNvbHZlZCBiaW5hcnkgcGF0aHMgdG8gYXZvaWQgcmVwZWF0ZWQgbG9va3Vwc1xyXG5jb25zdCBwYXRoQ2FjaGUgPSBuZXcgTWFwKCk7XHJcblxyXG4vKipcclxuICogUmVzb2x2ZXMgdGhlIHBhdGggdG8gYSBiaW5hcnkgZXhlY3V0YWJsZSB1c2luZyBtdWx0aXBsZSByZXNvbHV0aW9uIHN0cmF0ZWdpZXNcclxuICogQHBhcmFtIHtzdHJpbmd9IGJpbmFyeU5hbWUgLSBOYW1lIG9mIHRoZSBiaW5hcnkgdG8gcmVzb2x2ZSAoZS5nLiwgJ2ZmbXBlZycsICdmZnByb2JlJylcclxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBBZGRpdGlvbmFsIG9wdGlvbnNcclxuICogQHBhcmFtIHtib29sZWFufSBvcHRpb25zLmZvcmNlUmVmcmVzaCAtIFdoZXRoZXIgdG8gYnlwYXNzIHRoZSBjYWNoZSBhbmQgZm9yY2UgYSBmcmVzaCByZXNvbHV0aW9uXHJcbiAqIEBwYXJhbSB7c3RyaW5nW119IG9wdGlvbnMuY3VzdG9tUGF0aHMgLSBBZGRpdGlvbmFsIGN1c3RvbSBwYXRocyB0byBjaGVja1xyXG4gKiBAcmV0dXJucyB7c3RyaW5nfG51bGx9IFRoZSByZXNvbHZlZCBwYXRoIHRvIHRoZSBiaW5hcnkgb3IgbnVsbCBpZiBub3QgZm91bmRcclxuICovXHJcbmZ1bmN0aW9uIHJlc29sdmVCaW5hcnlQYXRoKGJpbmFyeU5hbWUsIG9wdGlvbnMgPSB7fSkge1xyXG4gICAgY29uc3QgeyBmb3JjZVJlZnJlc2ggPSBmYWxzZSwgY3VzdG9tUGF0aHMgPSBbXSB9ID0gb3B0aW9ucztcclxuICAgIFxyXG4gICAgLy8gTm9ybWFsaXplIGJpbmFyeSBuYW1lIGJhc2VkIG9uIHBsYXRmb3JtXHJcbiAgICBjb25zdCBub3JtYWxpemVkQmluYXJ5TmFtZSA9IG5vcm1hbGl6ZUJpbmFyeU5hbWUoYmluYXJ5TmFtZSk7XHJcbiAgICBjb25zdCBjYWNoZUtleSA9IG5vcm1hbGl6ZWRCaW5hcnlOYW1lO1xyXG4gICAgXHJcbiAgICAvLyBSZXR1cm4gY2FjaGVkIHBhdGggaWYgYXZhaWxhYmxlIGFuZCBub3QgZm9yY2luZyByZWZyZXNoXHJcbiAgICBpZiAoIWZvcmNlUmVmcmVzaCAmJiBwYXRoQ2FjaGUuaGFzKGNhY2hlS2V5KSkge1xyXG4gICAgICAgIGNvbnN0IGNhY2hlZFBhdGggPSBwYXRoQ2FjaGUuZ2V0KGNhY2hlS2V5KTtcclxuICAgICAgICBjb25zb2xlLmxvZyhgW0JpbmFyeVBhdGhSZXNvbHZlcl0gVXNpbmcgY2FjaGVkIHBhdGggZm9yICR7bm9ybWFsaXplZEJpbmFyeU5hbWV9OiAke2NhY2hlZFBhdGh9YCk7XHJcbiAgICAgICAgcmV0dXJuIGNhY2hlZFBhdGg7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGNvbnNvbGUubG9nKGBbQmluYXJ5UGF0aFJlc29sdmVyXSBSZXNvbHZpbmcgcGF0aCBmb3IgYmluYXJ5OiAke25vcm1hbGl6ZWRCaW5hcnlOYW1lfWApO1xyXG4gICAgXHJcbiAgICAvLyBEZXRlcm1pbmUgaWYgd2UncmUgaW4gcHJvZHVjdGlvbiBlbnZpcm9ubWVudFxyXG4gICAgY29uc3QgaXNQcm9kdWN0aW9uID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJyB8fCAoYXBwICYmIGFwcC5pc1BhY2thZ2VkKTtcclxuICAgIGNvbnNvbGUubG9nKGBbQmluYXJ5UGF0aFJlc29sdmVyXSBFbnZpcm9ubWVudDogJHtpc1Byb2R1Y3Rpb24gPyAnUHJvZHVjdGlvbicgOiAnRGV2ZWxvcG1lbnQnfWApO1xyXG4gICAgXHJcbiAgICAvLyBHZXQgcGxhdGZvcm0tc3BlY2lmaWMgcGF0aHMgdG8gY2hlY2tcclxuICAgIGNvbnN0IHBhdGhzVG9DaGVjayA9IGdldFBhdGhzVG9DaGVjayhub3JtYWxpemVkQmluYXJ5TmFtZSwgaXNQcm9kdWN0aW9uLCBjdXN0b21QYXRocyk7XHJcbiAgICBcclxuICAgIC8vIFRyeSBlYWNoIHBhdGggdW50aWwgd2UgZmluZCBvbmUgdGhhdCBleGlzdHMgYW5kIGlzIGV4ZWN1dGFibGVcclxuICAgIGZvciAoY29uc3QgYmluUGF0aCBvZiBwYXRoc1RvQ2hlY2spIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBpZiAodmVyaWZ5QmluYXJ5KGJpblBhdGgpKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgW0JpbmFyeVBhdGhSZXNvbHZlcl0gU3VjY2Vzc2Z1bGx5IHJlc29sdmVkICR7bm9ybWFsaXplZEJpbmFyeU5hbWV9IGF0OiAke2JpblBhdGh9YCk7XHJcbiAgICAgICAgICAgICAgICAvLyBDYWNoZSB0aGUgc3VjY2Vzc2Z1bCBwYXRoXHJcbiAgICAgICAgICAgICAgICBwYXRoQ2FjaGUuc2V0KGNhY2hlS2V5LCBiaW5QYXRoKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBiaW5QYXRoO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgLy8gSnVzdCBjb250aW51ZSB0byB0aGUgbmV4dCBwYXRoXHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbQmluYXJ5UGF0aFJlc29sdmVyXSBQYXRoICR7YmluUGF0aH0gZmFpbGVkIHZlcmlmaWNhdGlvbjogJHtlcnJvci5tZXNzYWdlfWApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gSWYgd2UgZ2V0IGhlcmUsIHdlIGNvdWxkbid0IGZpbmQgdGhlIGJpbmFyeVxyXG4gICAgY29uc29sZS5lcnJvcihgW0JpbmFyeVBhdGhSZXNvbHZlcl0gRmFpbGVkIHRvIHJlc29sdmUgcGF0aCBmb3IgJHtub3JtYWxpemVkQmluYXJ5TmFtZX1gKTtcclxuICAgIHJldHVybiBudWxsO1xyXG59XHJcblxyXG4vKipcclxuICogTm9ybWFsaXplcyBiaW5hcnkgbmFtZSBiYXNlZCBvbiBwbGF0Zm9ybSAoYWRkcyAuZXhlIGZvciBXaW5kb3dzKVxyXG4gKiBAcGFyYW0ge3N0cmluZ30gYmluYXJ5TmFtZSAtIE5hbWUgb2YgdGhlIGJpbmFyeVxyXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBOb3JtYWxpemVkIGJpbmFyeSBuYW1lXHJcbiAqL1xyXG5mdW5jdGlvbiBub3JtYWxpemVCaW5hcnlOYW1lKGJpbmFyeU5hbWUpIHtcclxuICAgIGNvbnN0IHBsYXRmb3JtID0gb3MucGxhdGZvcm0oKTtcclxuICAgIGlmIChwbGF0Zm9ybSA9PT0gJ3dpbjMyJyAmJiAhYmluYXJ5TmFtZS5lbmRzV2l0aCgnLmV4ZScpKSB7XHJcbiAgICAgICAgcmV0dXJuIGAke2JpbmFyeU5hbWV9LmV4ZWA7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYmluYXJ5TmFtZTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdldHMgYSBsaXN0IG9mIHBhdGhzIHRvIGNoZWNrIGZvciB0aGUgYmluYXJ5IGJhc2VkIG9uIGVudmlyb25tZW50IGFuZCBwbGF0Zm9ybVxyXG4gKiBAcGFyYW0ge3N0cmluZ30gYmluYXJ5TmFtZSAtIE5hbWUgb2YgdGhlIGJpbmFyeVxyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGlzUHJvZHVjdGlvbiAtIFdoZXRoZXIgd2UncmUgaW4gcHJvZHVjdGlvbiBtb2RlXHJcbiAqIEBwYXJhbSB7c3RyaW5nW119IGN1c3RvbVBhdGhzIC0gQWRkaXRpb25hbCBjdXN0b20gcGF0aHMgdG8gY2hlY2tcclxuICogQHJldHVybnMge3N0cmluZ1tdfSBBcnJheSBvZiBwYXRocyB0byBjaGVjayBpbiBwcmlvcml0eSBvcmRlclxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0UGF0aHNUb0NoZWNrKGJpbmFyeU5hbWUsIGlzUHJvZHVjdGlvbiwgY3VzdG9tUGF0aHMgPSBbXSkge1xyXG4gICAgY29uc3QgcGxhdGZvcm0gPSBvcy5wbGF0Zm9ybSgpO1xyXG4gICAgY29uc3QgcGF0aHMgPSBbXTtcclxuICAgIFxyXG4gICAgLy8gQWRkIGN1c3RvbSBwYXRocyBmaXJzdCAoaGlnaGVzdCBwcmlvcml0eSlcclxuICAgIGlmIChjdXN0b21QYXRocyAmJiBjdXN0b21QYXRocy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgcGF0aHMucHVzaCguLi5jdXN0b21QYXRocyk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIFByb2R1Y3Rpb24gcGF0aHMgLSBGRm1wZWcgYW5kIEZGcHJvYmUgYXJlIG5vIGxvbmdlciByZXF1aXJlZFxyXG4gICAgaWYgKGlzUHJvZHVjdGlvbikge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdbQmluYXJ5UGF0aFJlc29sdmVyXSBGRm1wZWcgYW5kIEZGcHJvYmUgYmluYXJpZXMgYXJlIG5vIGxvbmdlciByZXF1aXJlZCBpbiBwcm9kdWN0aW9uJyk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIERldmVsb3BtZW50IHBhdGhzXHJcbiAgICBpZiAoIWlzUHJvZHVjdGlvbikge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIC8vIEZGbXBlZyBhbmQgRkZwcm9iZSBhcmUgbm8gbG9uZ2VyIHJlcXVpcmVkIGZvciB0aGUgYXBwbGljYXRpb25cclxuICAgICAgICAgICAgY29uc29sZS5sb2coJ1tCaW5hcnlQYXRoUmVzb2x2ZXJdIEZGbXBlZyBhbmQgRkZwcm9iZSBhcmUgbm8gbG9uZ2VyIHJlcXVpcmVkJyk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvLyBGRm1wZWcgYW5kIEZGcHJvYmUgcGF0aHMgYXJlIG5vIGxvbmdlciBuZWVkZWRcclxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdbQmluYXJ5UGF0aFJlc29sdmVyXSBFcnJvciByZXNvbHZpbmcgZGV2ZWxvcG1lbnQgcGF0aHM6JywgZXJyb3IpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gTm8gc3lzdGVtIHBhdGhzIG5lZWRlZCBhcyBGRm1wZWcgYW5kIEZGcHJvYmUgYXJlIG5vIGxvbmdlciByZXF1aXJlZFxyXG4gICAgXHJcbiAgICAvLyBMb2cgYWxsIHBhdGhzIHdlJ3JlIGdvaW5nIHRvIGNoZWNrXHJcbiAgICBjb25zb2xlLmxvZyhgW0JpbmFyeVBhdGhSZXNvbHZlcl0gUGF0aHMgdG8gY2hlY2sgZm9yICR7YmluYXJ5TmFtZX06YCwgcGF0aHMpO1xyXG4gICAgXHJcbiAgICByZXR1cm4gcGF0aHM7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBWZXJpZmllcyB0aGF0IGEgYmluYXJ5IGV4aXN0cyBhbmQgaXMgZXhlY3V0YWJsZVxyXG4gKiBAcGFyYW0ge3N0cmluZ30gYmluYXJ5UGF0aCAtIFBhdGggdG8gdGhlIGJpbmFyeVxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgYmluYXJ5IGV4aXN0cyBhbmQgaXMgZXhlY3V0YWJsZVxyXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIGJpbmFyeSBkb2Vzbid0IGV4aXN0IG9yIGlzbid0IGV4ZWN1dGFibGVcclxuICovXHJcbmZ1bmN0aW9uIHZlcmlmeUJpbmFyeShiaW5hcnlQYXRoKSB7XHJcbiAgICBpZiAoIWJpbmFyeVBhdGgpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0JpbmFyeSBwYXRoIGlzIGVtcHR5IG9yIHVuZGVmaW5lZCcpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICB0cnkge1xyXG4gICAgICAgIC8vIENoZWNrIGlmIGZpbGUgZXhpc3RzXHJcbiAgICAgICAgaWYgKCFmcy5leGlzdHNTeW5jKGJpbmFyeVBhdGgpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQmluYXJ5IGRvZXMgbm90IGV4aXN0IGF0IHBhdGg6ICR7YmluYXJ5UGF0aH1gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gR2V0IGZpbGUgc3RhdHNcclxuICAgICAgICBjb25zdCBzdGF0cyA9IGZzLnN0YXRTeW5jKGJpbmFyeVBhdGgpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIENoZWNrIGlmIGl0J3MgYSBmaWxlIChub3QgYSBkaXJlY3RvcnkpXHJcbiAgICAgICAgaWYgKCFzdGF0cy5pc0ZpbGUoKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFBhdGggZXhpc3RzIGJ1dCBpcyBub3QgYSBmaWxlOiAke2JpbmFyeVBhdGh9YCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIE9uIFVuaXgtbGlrZSBzeXN0ZW1zLCBjaGVjayBpZiB0aGUgZmlsZSBpcyBleGVjdXRhYmxlXHJcbiAgICAgICAgY29uc3QgcGxhdGZvcm0gPSBvcy5wbGF0Zm9ybSgpO1xyXG4gICAgICAgIGlmIChwbGF0Zm9ybSAhPT0gJ3dpbjMyJykge1xyXG4gICAgICAgICAgICAvLyBDaGVjayBpZiBmaWxlIGhhcyBleGVjdXRlIHBlcm1pc3Npb24gKFVuaXgtbGlrZSBzeXN0ZW1zKVxyXG4gICAgICAgICAgICBjb25zdCBpc0V4ZWN1dGFibGUgPSAhIShzdGF0cy5tb2RlICYgMG8xMTEpOyAvLyBDaGVjayBpZiBhbnkgZXhlY3V0ZSBiaXQgaXMgc2V0XHJcbiAgICAgICAgICAgIGlmICghaXNFeGVjdXRhYmxlKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEJpbmFyeSBleGlzdHMgYnV0IGlzIG5vdCBleGVjdXRhYmxlOiAke2JpbmFyeVBhdGh9YCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gTG9nIGZpbGUgZGV0YWlscyBmb3IgZGVidWdnaW5nXHJcbiAgICAgICAgY29uc29sZS5sb2coYFtCaW5hcnlQYXRoUmVzb2x2ZXJdIFZlcmlmaWVkIGJpbmFyeSBhdCAke2JpbmFyeVBhdGh9YCk7XHJcbiAgICAgICAgY29uc29sZS5sb2coYFtCaW5hcnlQYXRoUmVzb2x2ZXJdIEZpbGUgc2l6ZTogJHtzdGF0cy5zaXplfSBieXRlc2ApO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGBbQmluYXJ5UGF0aFJlc29sdmVyXSBGaWxlIHBlcm1pc3Npb25zOiAke3N0YXRzLm1vZGUudG9TdHJpbmcoOCl9YCk7XHJcbiAgICAgICAgY29uc29sZS5sb2coYFtCaW5hcnlQYXRoUmVzb2x2ZXJdIExhc3QgbW9kaWZpZWQ6ICR7c3RhdHMubXRpbWV9YCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQmluYXJ5IHZlcmlmaWNhdGlvbiBmYWlsZWQ6ICR7ZXJyb3IubWVzc2FnZX1gKTtcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIENsZWFycyB0aGUgcGF0aCBjYWNoZVxyXG4gKi9cclxuZnVuY3Rpb24gY2xlYXJQYXRoQ2FjaGUoKSB7XHJcbiAgICBwYXRoQ2FjaGUuY2xlYXIoKTtcclxuICAgIGNvbnNvbGUubG9nKCdbQmluYXJ5UGF0aFJlc29sdmVyXSBQYXRoIGNhY2hlIGNsZWFyZWQnKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdldHMgdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIHBhdGggY2FjaGVcclxuICogQHJldHVybnMge09iamVjdH0gT2JqZWN0IHdpdGggYmluYXJ5IG5hbWVzIGFzIGtleXMgYW5kIHJlc29sdmVkIHBhdGhzIGFzIHZhbHVlc1xyXG4gKi9cclxuZnVuY3Rpb24gZ2V0UGF0aENhY2hlKCkge1xyXG4gICAgY29uc3QgY2FjaGUgPSB7fTtcclxuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHBhdGhDYWNoZS5lbnRyaWVzKCkpIHtcclxuICAgICAgICBjYWNoZVtrZXldID0gdmFsdWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY2FjaGU7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG4gICAgcmVzb2x2ZUJpbmFyeVBhdGgsXHJcbiAgICB2ZXJpZnlCaW5hcnksXHJcbiAgICBjbGVhclBhdGhDYWNoZSxcclxuICAgIGdldFBhdGhDYWNoZVxyXG59OyJdLCJtYXBwaW5ncyI6Ijs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE1BQU1BLElBQUksR0FBR0MsT0FBTyxDQUFDLE1BQU0sQ0FBQztBQUM1QixNQUFNQyxFQUFFLEdBQUdELE9BQU8sQ0FBQyxVQUFVLENBQUM7QUFDOUIsTUFBTTtFQUFFRTtBQUFJLENBQUMsR0FBR0YsT0FBTyxDQUFDLFVBQVUsQ0FBQztBQUNuQyxNQUFNRyxFQUFFLEdBQUdILE9BQU8sQ0FBQyxJQUFJLENBQUM7O0FBRXhCO0FBQ0EsTUFBTUksU0FBUyxHQUFHLElBQUlDLEdBQUcsQ0FBQyxDQUFDOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBU0MsaUJBQWlCQSxDQUFDQyxVQUFVLEVBQUVDLE9BQU8sR0FBRyxDQUFDLENBQUMsRUFBRTtFQUNqRCxNQUFNO0lBQUVDLFlBQVksR0FBRyxLQUFLO0lBQUVDLFdBQVcsR0FBRztFQUFHLENBQUMsR0FBR0YsT0FBTzs7RUFFMUQ7RUFDQSxNQUFNRyxvQkFBb0IsR0FBR0MsbUJBQW1CLENBQUNMLFVBQVUsQ0FBQztFQUM1RCxNQUFNTSxRQUFRLEdBQUdGLG9CQUFvQjs7RUFFckM7RUFDQSxJQUFJLENBQUNGLFlBQVksSUFBSUwsU0FBUyxDQUFDVSxHQUFHLENBQUNELFFBQVEsQ0FBQyxFQUFFO0lBQzFDLE1BQU1FLFVBQVUsR0FBR1gsU0FBUyxDQUFDWSxHQUFHLENBQUNILFFBQVEsQ0FBQztJQUMxQ0ksT0FBTyxDQUFDQyxHQUFHLENBQUMsOENBQThDUCxvQkFBb0IsS0FBS0ksVUFBVSxFQUFFLENBQUM7SUFDaEcsT0FBT0EsVUFBVTtFQUNyQjtFQUVBRSxPQUFPLENBQUNDLEdBQUcsQ0FBQyxtREFBbURQLG9CQUFvQixFQUFFLENBQUM7O0VBRXRGO0VBQ0EsTUFBTVEsWUFBWSxHQUFHQyxPQUFPLENBQUNDLEdBQUcsQ0FBQ0MsUUFBUSxLQUFLLFlBQVksSUFBS3BCLEdBQUcsSUFBSUEsR0FBRyxDQUFDcUIsVUFBVztFQUNyRk4sT0FBTyxDQUFDQyxHQUFHLENBQUMscUNBQXFDQyxZQUFZLEdBQUcsWUFBWSxHQUFHLGFBQWEsRUFBRSxDQUFDOztFQUUvRjtFQUNBLE1BQU1LLFlBQVksR0FBR0MsZUFBZSxDQUFDZCxvQkFBb0IsRUFBRVEsWUFBWSxFQUFFVCxXQUFXLENBQUM7O0VBRXJGO0VBQ0EsS0FBSyxNQUFNZ0IsT0FBTyxJQUFJRixZQUFZLEVBQUU7SUFDaEMsSUFBSTtNQUNBLElBQUlHLFlBQVksQ0FBQ0QsT0FBTyxDQUFDLEVBQUU7UUFDdkJULE9BQU8sQ0FBQ0MsR0FBRyxDQUFDLDhDQUE4Q1Asb0JBQW9CLFFBQVFlLE9BQU8sRUFBRSxDQUFDO1FBQ2hHO1FBQ0F0QixTQUFTLENBQUN3QixHQUFHLENBQUNmLFFBQVEsRUFBRWEsT0FBTyxDQUFDO1FBQ2hDLE9BQU9BLE9BQU87TUFDbEI7SUFDSixDQUFDLENBQUMsT0FBT0csS0FBSyxFQUFFO01BQ1o7TUFDQVosT0FBTyxDQUFDQyxHQUFHLENBQUMsNkJBQTZCUSxPQUFPLHlCQUF5QkcsS0FBSyxDQUFDQyxPQUFPLEVBQUUsQ0FBQztJQUM3RjtFQUNKOztFQUVBO0VBQ0FiLE9BQU8sQ0FBQ1ksS0FBSyxDQUFDLG1EQUFtRGxCLG9CQUFvQixFQUFFLENBQUM7RUFDeEYsT0FBTyxJQUFJO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVNDLG1CQUFtQkEsQ0FBQ0wsVUFBVSxFQUFFO0VBQ3JDLE1BQU13QixRQUFRLEdBQUc1QixFQUFFLENBQUM0QixRQUFRLENBQUMsQ0FBQztFQUM5QixJQUFJQSxRQUFRLEtBQUssT0FBTyxJQUFJLENBQUN4QixVQUFVLENBQUN5QixRQUFRLENBQUMsTUFBTSxDQUFDLEVBQUU7SUFDdEQsT0FBTyxHQUFHekIsVUFBVSxNQUFNO0VBQzlCO0VBQ0EsT0FBT0EsVUFBVTtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVNrQixlQUFlQSxDQUFDbEIsVUFBVSxFQUFFWSxZQUFZLEVBQUVULFdBQVcsR0FBRyxFQUFFLEVBQUU7RUFDakUsTUFBTXFCLFFBQVEsR0FBRzVCLEVBQUUsQ0FBQzRCLFFBQVEsQ0FBQyxDQUFDO0VBQzlCLE1BQU1FLEtBQUssR0FBRyxFQUFFOztFQUVoQjtFQUNBLElBQUl2QixXQUFXLElBQUlBLFdBQVcsQ0FBQ3dCLE1BQU0sR0FBRyxDQUFDLEVBQUU7SUFDdkNELEtBQUssQ0FBQ0UsSUFBSSxDQUFDLEdBQUd6QixXQUFXLENBQUM7RUFDOUI7O0VBRUE7RUFDQSxJQUFJUyxZQUFZLEVBQUU7SUFDZEYsT0FBTyxDQUFDQyxHQUFHLENBQUMsdUZBQXVGLENBQUM7RUFDeEc7O0VBRUE7RUFDQSxJQUFJLENBQUNDLFlBQVksRUFBRTtJQUNmLElBQUk7TUFDQTtNQUNBRixPQUFPLENBQUNDLEdBQUcsQ0FBQyxnRUFBZ0UsQ0FBQzs7TUFFN0U7SUFDSixDQUFDLENBQUMsT0FBT1csS0FBSyxFQUFFO01BQ1paLE9BQU8sQ0FBQ1ksS0FBSyxDQUFDLHlEQUF5RCxFQUFFQSxLQUFLLENBQUM7SUFDbkY7RUFDSjs7RUFFQTs7RUFFQTtFQUNBWixPQUFPLENBQUNDLEdBQUcsQ0FBQywyQ0FBMkNYLFVBQVUsR0FBRyxFQUFFMEIsS0FBSyxDQUFDO0VBRTVFLE9BQU9BLEtBQUs7QUFDaEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBU04sWUFBWUEsQ0FBQ1MsVUFBVSxFQUFFO0VBQzlCLElBQUksQ0FBQ0EsVUFBVSxFQUFFO0lBQ2IsTUFBTSxJQUFJQyxLQUFLLENBQUMsbUNBQW1DLENBQUM7RUFDeEQ7RUFFQSxJQUFJO0lBQ0E7SUFDQSxJQUFJLENBQUNwQyxFQUFFLENBQUNxQyxVQUFVLENBQUNGLFVBQVUsQ0FBQyxFQUFFO01BQzVCLE1BQU0sSUFBSUMsS0FBSyxDQUFDLGtDQUFrQ0QsVUFBVSxFQUFFLENBQUM7SUFDbkU7O0lBRUE7SUFDQSxNQUFNRyxLQUFLLEdBQUd0QyxFQUFFLENBQUN1QyxRQUFRLENBQUNKLFVBQVUsQ0FBQzs7SUFFckM7SUFDQSxJQUFJLENBQUNHLEtBQUssQ0FBQ0UsTUFBTSxDQUFDLENBQUMsRUFBRTtNQUNqQixNQUFNLElBQUlKLEtBQUssQ0FBQyxrQ0FBa0NELFVBQVUsRUFBRSxDQUFDO0lBQ25FOztJQUVBO0lBQ0EsTUFBTUwsUUFBUSxHQUFHNUIsRUFBRSxDQUFDNEIsUUFBUSxDQUFDLENBQUM7SUFDOUIsSUFBSUEsUUFBUSxLQUFLLE9BQU8sRUFBRTtNQUN0QjtNQUNBLE1BQU1XLFlBQVksR0FBRyxDQUFDLEVBQUVILEtBQUssQ0FBQ0ksSUFBSSxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUM7TUFDN0MsSUFBSSxDQUFDRCxZQUFZLEVBQUU7UUFDZixNQUFNLElBQUlMLEtBQUssQ0FBQyx3Q0FBd0NELFVBQVUsRUFBRSxDQUFDO01BQ3pFO0lBQ0o7O0lBRUE7SUFDQW5CLE9BQU8sQ0FBQ0MsR0FBRyxDQUFDLDJDQUEyQ2tCLFVBQVUsRUFBRSxDQUFDO0lBQ3BFbkIsT0FBTyxDQUFDQyxHQUFHLENBQUMsbUNBQW1DcUIsS0FBSyxDQUFDSyxJQUFJLFFBQVEsQ0FBQztJQUNsRTNCLE9BQU8sQ0FBQ0MsR0FBRyxDQUFDLDBDQUEwQ3FCLEtBQUssQ0FBQ0ksSUFBSSxDQUFDRSxRQUFRLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQztJQUMvRTVCLE9BQU8sQ0FBQ0MsR0FBRyxDQUFDLHVDQUF1Q3FCLEtBQUssQ0FBQ08sS0FBSyxFQUFFLENBQUM7SUFFakUsT0FBTyxJQUFJO0VBQ2YsQ0FBQyxDQUFDLE9BQU9qQixLQUFLLEVBQUU7SUFDWixNQUFNLElBQUlRLEtBQUssQ0FBQywrQkFBK0JSLEtBQUssQ0FBQ0MsT0FBTyxFQUFFLENBQUM7RUFDbkU7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTaUIsY0FBY0EsQ0FBQSxFQUFHO0VBQ3RCM0MsU0FBUyxDQUFDNEMsS0FBSyxDQUFDLENBQUM7RUFDakIvQixPQUFPLENBQUNDLEdBQUcsQ0FBQyx5Q0FBeUMsQ0FBQztBQUMxRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMrQixZQUFZQSxDQUFBLEVBQUc7RUFDcEIsTUFBTUMsS0FBSyxHQUFHLENBQUMsQ0FBQztFQUNoQixLQUFLLE1BQU0sQ0FBQ0MsR0FBRyxFQUFFQyxLQUFLLENBQUMsSUFBSWhELFNBQVMsQ0FBQ2lELE9BQU8sQ0FBQyxDQUFDLEVBQUU7SUFDNUNILEtBQUssQ0FBQ0MsR0FBRyxDQUFDLEdBQUdDLEtBQUs7RUFDdEI7RUFDQSxPQUFPRixLQUFLO0FBQ2hCO0FBRUFJLE1BQU0sQ0FBQ0MsT0FBTyxHQUFHO0VBQ2JqRCxpQkFBaUI7RUFDakJxQixZQUFZO0VBQ1pvQixjQUFjO0VBQ2RFO0FBQ0osQ0FBQyIsImlnbm9yZUxpc3QiOltdfQ==